pcap-util.c:EXTRACT_BE_U_2:
   78|  7.40k|{
   79|  7.40k|	return ((uint16_t)ntohs(*(const uint16_t *)(p)));
   80|  7.40k|}

pcap_freecode:
 1262|  1.89k|{
 1263|  1.89k|	program->bf_len = 0;
 1264|  1.89k|	if (program->bf_insns != NULL) {
  ------------------
  |  Branch (1264:6): [True: 0, False: 1.89k]
  ------------------
 1265|      0|		free((char *)program->bf_insns);
 1266|      0|		program->bf_insns = NULL;
 1267|      0|	}
 1268|  1.89k|}

linktype_to_dlt:
 1474|  1.89k|{
 1475|       |	/*
 1476|       |	 * All values in the low matching range were handed out before
 1477|       |	 * assigning DLT_* codes became a free-for-all, so they're the
 1478|       |	 * same on all platforms, and are thus used as the LINKTYPE_*
 1479|       |	 * codes in capture files.
 1480|       |	 */
 1481|  1.89k|	if (linktype >= LINKTYPE_LOW_MATCHING_MIN &&
  ------------------
  |  |  110|  3.79k|#define LINKTYPE_LOW_MATCHING_MIN	0		/* lowest value in this "matching" range */
  ------------------
  |  Branch (1481:6): [True: 1.89k, False: 0]
  ------------------
 1482|  1.89k|	    linktype <= LINKTYPE_LOW_MATCHING_MAX)
  ------------------
  |  |  123|  1.89k|#define LINKTYPE_LOW_MATCHING_MAX	LINKTYPE_FDDI	/* highest value in this "matching" range */
  |  |  ------------------
  |  |  |  |  121|  1.89k|#define LINKTYPE_FDDI		DLT_FDDI
  |  |  |  |  ------------------
  |  |  |  |  |  |   77|  1.89k|#define DLT_FDDI	10	/* FDDI */
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1482:6): [True: 785, False: 1.11k]
  ------------------
 1483|    785|		return (linktype);
 1484|       |
 1485|       |#if LINKTYPE_PFSYNC != DLT_PFSYNC
 1486|       |	/*
 1487|       |	 * DLT_PFSYNC has a code on several platforms that's in the
 1488|       |	 * non-matching range, a code on FreeBSD that's in the high
 1489|       |	 * matching range and that's *not* equal to LINKTYPE_PFSYNC,
 1490|       |	 * and has a code on the rmaining platforms that's equal
 1491|       |	 * to LINKTYPE_PFSYNC, which is in the high matching range.
 1492|       |	 *
 1493|       |	 * Map LINKTYPE_PFSYNC to whatever DLT_PFSYNC is on this
 1494|       |	 * platform, if the two aren't equal.
 1495|       |	 */
 1496|       |	if (linktype == LINKTYPE_PFSYNC)
 1497|       |		return (DLT_PFSYNC);
 1498|       |#endif
 1499|       |
 1500|       |	/*
 1501|       |	 * DLT_PKTAP is defined as DLT_USER2 - which is in the high
 1502|       |	 * matching range - on Darwin because Apple used DLT_USER2
 1503|       |	 * on systems that users ran, not just as an internal thing.
 1504|       |	 *
 1505|       |	 * We map LINKTYPE_PKTAP to the platform's DLT_PKTAP for
 1506|       |	 * the benefit of software that's expecting DLT_PKTAP
 1507|       |	 * (even if that's DLT_USER2) for an Apple PKTAP capture.
 1508|       |	 *
 1509|       |	 * (Yes, this is an annoyance if you want to read a
 1510|       |	 * LINKTYPE_USER2 packet as something other than DLT_PKTAP
 1511|       |	 * on a Darwin-based OS, as, on that OS, DLT_PKTAP and DLT_USER2
 1512|       |	 * are the same.  Feel free to complain to Apple about this.)
 1513|       |	 */
 1514|       |#if LINKTYPE_PKTAP != DLT_PKTAP
 1515|       |	if (linktype == LINKTYPE_PKTAP)
 1516|       |		return (DLT_PKTAP);
 1517|       |#endif
 1518|       |
 1519|       |	/*
 1520|       |	 * These DLT_* codes have different values on different
 1521|       |	 * platforms, so we assigned them LINKTYPE_* codes just
 1522|       |	 * below the lower bound of the high matching range;
 1523|       |	 * those values should never be equal to any DLT_*
 1524|       |	 * code, so that should avoid collisions.
 1525|       |	 *
 1526|       |	 * That way, for example, "raw IP" packets will have
 1527|       |	 * LINKTYPE_RAW as the code in all savefiles for
 1528|       |	 * which the code that writes them maps to that
 1529|       |	 * value, regardless of the platform on which they
 1530|       |	 * were written, so they should be readable on all
 1531|       |	 * platforms without having to determine on which
 1532|       |	 * platform they were written.
 1533|       |	 *
 1534|       |	 * We map the LINKTYPE_* codes to the corresponding
 1535|       |	 * DLT_* code on this platform.
 1536|       |	 */
 1537|  1.11k|	if (linktype == LINKTYPE_ATM_RFC1483)
  ------------------
  |  |  152|  1.11k|#define LINKTYPE_ATM_RFC1483	100		/* LLC/SNAP-encapsulated ATM */
  ------------------
  |  Branch (1537:6): [True: 7, False: 1.10k]
  ------------------
 1538|      7|		return (DLT_ATM_RFC1483);
  ------------------
  |  |  109|      7|#define DLT_ATM_RFC1483	11	/* LLC-encapsulated ATM */
  ------------------
 1539|  1.10k|	if (linktype == LINKTYPE_RAW)
  ------------------
  |  |  153|  1.10k|#define LINKTYPE_RAW		101		/* raw IP */
  ------------------
  |  Branch (1539:6): [True: 11, False: 1.09k]
  ------------------
 1540|     11|		return (DLT_RAW);
  ------------------
  |  |  114|     11|#define DLT_RAW		12	/* raw IP */
  ------------------
 1541|  1.09k|	if (linktype == LINKTYPE_SLIP_BSDOS)
  ------------------
  |  |  154|  1.09k|#define LINKTYPE_SLIP_BSDOS	102		/* BSD/OS SLIP BPF header */
  ------------------
  |  Branch (1541:6): [True: 1, False: 1.09k]
  ------------------
 1542|      1|		return (DLT_SLIP_BSDOS);
  ------------------
  |  |  129|      1|#define DLT_SLIP_BSDOS	15	/* BSD/OS Serial Line IP */
  ------------------
 1543|  1.09k|	if (linktype == LINKTYPE_PPP_BSDOS)
  ------------------
  |  |  155|  1.09k|#define LINKTYPE_PPP_BSDOS	103		/* BSD/OS PPP BPF header */
  ------------------
  |  Branch (1543:6): [True: 1, False: 1.09k]
  ------------------
 1544|      1|		return (DLT_PPP_BSDOS);
  ------------------
  |  |  130|      1|#define DLT_PPP_BSDOS	16	/* BSD/OS Point-to-point Protocol */
  ------------------
 1545|       |
 1546|       |	/*
 1547|       |	 * These DLT_* codes were originally defined on some platform,
 1548|       |	 * and weren't defined on other platforms.
 1549|       |	 *
 1550|       |	 * At least some of them have values, on at least one platform,
 1551|       |	 * that collide with other DLT_* codes on other platforms, e.g.
 1552|       |	 * DLT_LOOP, so we don't just define them, on all platforms,
 1553|       |	 * as having the same value as on the original platform.
 1554|       |	 *
 1555|       |	 * Therefore, we assigned new LINKTYPE_* codes to them, and,
 1556|       |	 * on the platforms where they weren't originally defined,
 1557|       |	 * define the DLT_* codes to have the same value as the
 1558|       |	 * corresponding LINKTYPE_* codes.
 1559|       |	 *
 1560|       |	 * This means that, for capture files with the original
 1561|       |	 * platform's DLT_* code rather than the LINKTYPE_* code
 1562|       |	 * as a link-layer type, we will recognize those types
 1563|       |	 * on that platform, but not on other platforms.
 1564|       |	 *
 1565|       |	 * We map the LINKTYPE_* codes to the corresponding
 1566|       |	 * DLT_* code on platforms where the two codes differ..
 1567|       |	 */
 1568|       |#ifdef DLT_FR
 1569|       |	/* BSD/OS Frame Relay */
 1570|       |	if (linktype == LINKTYPE_FRELAY)
 1571|       |		return (DLT_FR);
 1572|       |#endif
 1573|       |#if LINKTYPE_NETBSD_HDLC != DLT_HDLC
 1574|       |	/* NetBSD HDLC */
 1575|       |	if (linktype == LINKTYPE_NETBSD_HDLC)
 1576|       |		return (DLT_HDLC);
 1577|       |#endif
 1578|       |#if LINKTYPE_C_HDLC != DLT_C_HDLC
 1579|       |	/* BSD/OS Cisco HDLC */
 1580|       |	if (linktype == LINKTYPE_C_HDLC)
 1581|       |		return (DLT_C_HDLC);
 1582|       |#endif
 1583|       |#if LINKTYPE_LOOP != DLT_LOOP
 1584|       |	/* OpenBSD DLT_LOOP */
 1585|       |	if (linktype == LINKTYPE_LOOP)
 1586|       |		return (DLT_LOOP);
 1587|       |#endif
 1588|       |#if LINKTYPE_ENC != DLT_ENC
 1589|       |	/* OpenBSD DLT_ENC */
 1590|       |	if (linktype == LINKTYPE_ENC)
 1591|       |		return (DLT_ENC);
 1592|       |#endif
 1593|       |
 1594|       |	/*
 1595|       |	 * These DLT_* codes are not on all platforms, but, so far,
 1596|       |	 * there don't appear to be any platforms that define
 1597|       |	 * other codes with those values; we map them to
 1598|       |	 * different LINKTYPE_* values anyway, just in case.
 1599|       |	 *
 1600|       |	 * LINKTYPE_ATM_CLIP is a special case.  DLT_ATM_CLIP is
 1601|       |	 * not on all platforms, but, so far, there don't appear
 1602|       |	 * to be any platforms that define it as anything other
 1603|       |	 * than 19; we define LINKTYPE_ATM_CLIP as something
 1604|       |	 * other than 19, just in case.  That value is in the
 1605|       |	 * high matching range, so we have to check for it.
 1606|       |	 */
 1607|       |	/* Linux ATM Classical IP */
 1608|  1.09k|	if (linktype == LINKTYPE_ATM_CLIP)
  ------------------
  |  |  171|  1.09k|#define LINKTYPE_ATM_CLIP	106		/* Linux Classical IP over ATM */
  ------------------
  |  Branch (1608:6): [True: 3, False: 1.09k]
  ------------------
 1609|      3|		return (DLT_ATM_CLIP);
  ------------------
  |  |  224|      3|#define DLT_ATM_CLIP	19	/* Linux Classical IP over ATM */
  ------------------
 1610|       |
 1611|       |	/*
 1612|       |	 * For all other values, return the linktype code as the
 1613|       |	 * DLT_* code.
 1614|       |	 *
 1615|       |	 * If the code is in the high matching range, the
 1616|       |	 * DLT_* code is the same as the LINKTYPE_* code.
 1617|       |	 *
 1618|       |	 * If the code is greater than the maximum value in
 1619|       |	 * the high matching range, it may be a value from
 1620|       |	 * a newer version of libpcap; we provide it in case
 1621|       |	 * the program' capable of handling it.
 1622|       |	 *
 1623|       |	 * If the code is less than the minimum value in the
 1624|       |	 * high matching range, it might be from a capture
 1625|       |	 * written by code that doesn't map non-matching range
 1626|       |	 * DLT_* codes to the appropriate LINKTYPE_* code, so
 1627|       |	 * we'll just pass it through, so that *if it was written
 1628|       |	 * on this platform* it will be interpreted correctly.
 1629|       |	 * (We don't know whether it was written on this platform,
 1630|       |	 * but at least this way there's *some* chance that it
 1631|       |	 * can be read.)
 1632|       |	 */
 1633|  1.09k|	return linktype;
 1634|  1.09k|}
max_snaplen_for_dlt:
 1655|  48.5k|{
 1656|  48.5k|	switch (dlt) {
 1657|       |
 1658|    241|	case DLT_DBUS:
  ------------------
  |  | 1171|    241|#define DLT_DBUS		231
  ------------------
  |  Branch (1658:2): [True: 241, False: 48.2k]
  ------------------
 1659|    241|		return 128*1024*1024;
 1660|       |
 1661|    386|	case DLT_EBHSCR:
  ------------------
  |  | 1538|    386|#define DLT_EBHSCR	        279
  ------------------
  |  Branch (1661:2): [True: 386, False: 48.1k]
  ------------------
 1662|    386|		return 8*1024*1024;
 1663|       |
 1664|    225|	case DLT_USBPCAP:
  ------------------
  |  | 1303|    225|#define DLT_USBPCAP		249
  ------------------
  |  Branch (1664:2): [True: 225, False: 48.2k]
  ------------------
 1665|    225|		return 1024*1024;
 1666|       |
 1667|  47.6k|	default:
  ------------------
  |  Branch (1667:2): [True: 47.6k, False: 852]
  ------------------
 1668|  47.6k|		return MAXIMUM_SNAPLEN;
  ------------------
  |  |  138|  47.6k|#define MAXIMUM_SNAPLEN		262144
  ------------------
 1669|  48.5k|	}
 1670|  48.5k|}

pcap-util.c:is_isochronous_transfer_completion:
   43|    872|{
   44|    872|	return (hdr->transfer_type == URB_ISOCHRONOUS &&
  ------------------
  |  |   43|  1.74k|#define URB_ISOCHRONOUS   0x0
  ------------------
  |  Branch (44:10): [True: 859, False: 13]
  ------------------
   45|    872|	    hdr->event_type == URB_COMPLETE &&
  ------------------
  |  |   52|  1.73k|#define URB_COMPLETE      'C'
  ------------------
  |  Branch (45:6): [True: 72, False: 787]
  ------------------
   46|    872|	    (hdr->endpoint_number & URB_TRANSFER_IN));
  ------------------
  |  |   42|     72|#define URB_TRANSFER_IN   0x80
  ------------------
  |  Branch (46:6): [True: 71, False: 1]
  ------------------
   47|    872|}
pcap-util.c:iso_pseudo_header_len:
   55|    183|{
   56|    183|	return (sizeof(pcap_usb_header_mmapped) +
   57|    183|	    usb_hdr->ndesc * sizeof (usb_isodesc));
   58|    183|}
pcap-util.c:incoming_isochronous_transfer_completed_len:
   71|     51|{
   72|     51|	const pcap_usb_header_mmapped *hdr;
   73|     51|	u_int bytes_left;
   74|     51|	const usb_isodesc *descs;
   75|     51|	u_int pre_truncation_data_len;
   76|       |
   77|       |	/*
   78|       |	 * All callers of this routine must ensure that pkth->caplen is
   79|       |	 * >= sizeof (pcap_usb_header_mmapped).
   80|       |	 */
   81|     51|	bytes_left = phdr->caplen;
   82|     51|	bytes_left -= sizeof (pcap_usb_header_mmapped);
   83|       |
   84|     51|	hdr = (const pcap_usb_header_mmapped *) bp;
   85|     51|	descs = (const usb_isodesc *) (bp + sizeof(pcap_usb_header_mmapped));
   86|       |
   87|       |	/*
   88|       |	 * Find the end of the last chunk of data in the buffer
   89|       |	 * referred to by the isochronous descriptors; that indicates
   90|       |	 * how far into the buffer the data would have gone.
   91|       |	 *
   92|       |	 * Make sure we don't run past the end of the captured data
   93|       |	 * while processing the isochronous descriptors.
   94|       |	 */
   95|     51|	pre_truncation_data_len = 0;
   96|     51|	for (uint32_t desc = 0;
   97|    563|	    desc < hdr->ndesc && bytes_left >= sizeof (usb_isodesc);
  ------------------
  |  Branch (97:6): [True: 512, False: 51]
  |  Branch (97:27): [True: 512, False: 0]
  ------------------
   98|    512|	    desc++, bytes_left -= sizeof (usb_isodesc)) {
   99|    512|		u_int desc_end;
  100|       |
  101|    512|		if (descs[desc].len != 0) {
  ------------------
  |  Branch (101:7): [True: 371, False: 141]
  ------------------
  102|       |			/*
  103|       |			 * Compute the end offset of the data
  104|       |			 * for this descriptor, i.e. the offset
  105|       |			 * of the byte after the data.  Clamp
  106|       |			 * the sum at UINT_MAX, so that it fits
  107|       |			 * in a u_int.
  108|       |			 */
  109|    371|			desc_end = u_int_sum(descs[desc].offset,
  110|    371|			    descs[desc].len);
  111|    371|			if (desc_end > pre_truncation_data_len)
  ------------------
  |  Branch (111:8): [True: 72, False: 299]
  ------------------
  112|     72|				pre_truncation_data_len = desc_end;
  113|    371|		}
  114|    512|	}
  115|       |
  116|       |	/*
  117|       |	 * Return the sum of the total header length (memory-mapped
  118|       |	 * header and ISO descriptors) and the data length, clamped
  119|       |	 * to UINT_MAX.
  120|       |	 *
  121|       |	 * We've made sure that the number of descriptors is
  122|       |	 * <= USB_MAXDESC, so we know that the total size,
  123|       |	 * in bytes, of the descriptors fits in a 32-bit
  124|       |	 * integer.
  125|       |	 */
  126|     51|	return (u_int_sum(iso_pseudo_header_len(hdr), pre_truncation_data_len));
  127|     51|}
pcap-util.c:u_int_sum:
   34|    422|{
   35|    422|	return (((b) <= UINT_MAX - (a)) ? (a) + (b) : UINT_MAX);
  ------------------
  |  Branch (35:10): [True: 232, False: 190]
  ------------------
   36|    422|}

pcapint_post_process:
  508|  49.1k|{
  509|  49.1k|	if (swapped)
  ------------------
  |  Branch (509:6): [True: 33.4k, False: 15.7k]
  ------------------
  510|  33.4k|		swap_pseudo_headers(linktype, hdr, data);
  511|       |
  512|       |	/*
  513|       |	 * Is this a memory-mapped Linux USB capture?
  514|       |	 */
  515|  49.1k|	if (linktype == DLT_USB_LINUX_MMAPPED) {
  ------------------
  |  | 1034|  49.1k|#define DLT_USB_LINUX_MMAPPED	220
  ------------------
  |  Branch (515:6): [True: 12.0k, False: 37.1k]
  ------------------
  516|       |		/*
  517|       |		 * Yes.
  518|       |		 *
  519|       |		 * In older versions of libpcap, in memory-mapped Linux
  520|       |		 * USB captures, the original length of completion events
  521|       |		 * for incoming isochronous transfers was miscalculated;
  522|       |		 * it needed to be calculated based on the offsets and
  523|       |		 * lengths in the descriptors, not on the raw URB length,
  524|       |		 * but it wasn't.
  525|       |		 *
  526|       |		 * If this packet contains transferred data (yes, data_flag
  527|       |		 * is 0 if we *do* have data), it's a completion event
  528|       |		 * for an incoming isochronous transfer, and the
  529|       |		 * transfer length appears to have been calculated
  530|       |		 * from the raw URB length, fix it.
  531|       |		 *
  532|       |		 * We only do this if we have the full USB pseudo-header,
  533|       |		 * because we will have to look at that header and at
  534|       |		 * all of the isochronous descriptors.
  535|       |		 */
  536|  12.0k|		if (hdr->caplen < sizeof (pcap_usb_header_mmapped)) {
  ------------------
  |  Branch (536:7): [True: 10.2k, False: 1.81k]
  ------------------
  537|       |			/*
  538|       |			 * We don't have the full pseudo-header.
  539|       |			 */
  540|  10.2k|			return;
  541|  10.2k|		}
  542|       |
  543|  1.81k|		const pcap_usb_header_mmapped *usb_hdr =
  544|  1.81k|		    (const pcap_usb_header_mmapped *) data;
  545|       |
  546|       |		/*
  547|       |		 * Make sure the number of descriptors is sane.
  548|       |		 *
  549|       |		 * The Linux binary USB monitor code limits the number of
  550|       |		 * isochronous descriptors to 128; if the number in the file
  551|       |		 * is larger than that, either 1) the file's been damaged
  552|       |		 * or 2) the file was produced after the number was raised
  553|       |		 * in the kernel.
  554|       |		 *
  555|       |		 * In case 1), the number can't be trusted, so don't rely on
  556|       |		 * it to attempt to fix the original length field in the pcap
  557|       |		 * or pcapng header.
  558|       |		 *
  559|       |		 * In case 2), the system was probably running a version of
  560|       |		 * libpcap that didn't miscalculate the original length, so
  561|       |		 * it probably doesn't need to be fixed.
  562|       |		 *
  563|       |		 * This avoids the possibility of the product of the number of
  564|       |		 * descriptors and the size of descriptors won't overflow an
  565|       |		 * unsigned 32-bit integer.
  566|       |		 */
  567|  1.81k|		if (usb_hdr->ndesc > USB_MAXDESC)
  ------------------
  |  |  132|  1.81k|#define USB_MAXDESC	128
  ------------------
  |  Branch (567:7): [True: 914, False: 897]
  ------------------
  568|    914|			return;
  569|       |
  570|    897|		if (!usb_hdr->data_flag &&
  ------------------
  |  Branch (570:7): [True: 872, False: 25]
  ------------------
  571|    897|		    is_isochronous_transfer_completion(usb_hdr) &&
  ------------------
  |  Branch (571:7): [True: 71, False: 801]
  ------------------
  572|    897|		    packet_length_might_be_wrong(hdr, usb_hdr)) {
  ------------------
  |  Branch (572:7): [True: 61, False: 10]
  ------------------
  573|     61|			u_int len;
  574|       |
  575|       |			/*
  576|       |			 * Make sure we have all of the descriptors,
  577|       |			 * as we will have to look at all of them.
  578|       |			 *
  579|       |			 * If not, we don't bother trying to fix
  580|       |			 * anything.
  581|       |			 */
  582|     61|			if (hdr->caplen < iso_pseudo_header_len(usb_hdr))
  ------------------
  |  Branch (582:8): [True: 10, False: 51]
  ------------------
  583|     10|				return;
  584|       |
  585|       |			/*
  586|       |			 * Calculate what the length should have been.
  587|       |			 */
  588|     51|			len = incoming_isochronous_transfer_completed_len(hdr,
  589|     51|			    data);
  590|       |
  591|       |			/*
  592|       |			 * len is the smaller of UINT_MAX and the total
  593|       |			 * header plus data length.  That's guaranteed
  594|       |			 * to fit in a UINT_MAX.
  595|       |			 *
  596|       |			 * Don't reduce the original length to a value
  597|       |			 * below the captured length, however, as that
  598|       |			 * is bogus.
  599|       |			 */
  600|     51|			if (len >= hdr->caplen)
  ------------------
  |  Branch (600:8): [True: 30, False: 21]
  ------------------
  601|     30|				hdr->len = len;
  602|       |
  603|       |			/*
  604|       |			 * If the captured length is greater than the
  605|       |			 * length, use the captured length.
  606|       |			 *
  607|       |			 * For completion events for incoming isochronous
  608|       |			 * transfers, it's based on data_len, which is
  609|       |			 * calculated the same way we calculated
  610|       |			 * pre_truncation_data_len above, except that
  611|       |			 * it has access to all the isochronous descriptors,
  612|       |			 * not just the ones that the kernel were able to
  613|       |			 * provide us or, for a capture file, that weren't
  614|       |			 * sliced off by a snapshot length.
  615|       |			 *
  616|       |			 * However, it might have been reduced by the USB
  617|       |			 * capture mechanism arbitrarily limiting the amount
  618|       |			 * of data it provides to userland, or by the libpcap
  619|       |			 * capture code limiting it to being no more than the
  620|       |			 * snapshot, so we don't want to just use it all the
  621|       |			 * time; we only do so to try to get a better estimate
  622|       |			 * of the actual length - and to make sure the
  623|       |			 * original length is always >= the captured length.
  624|       |			 */
  625|     51|			if (hdr->caplen > hdr->len)
  ------------------
  |  Branch (625:8): [True: 21, False: 30]
  ------------------
  626|     21|				hdr->len = hdr->caplen;
  627|     51|		}
  628|    897|	}
  629|  49.1k|}
pcap-util.c:swap_pseudo_headers:
  453|  33.4k|{
  454|       |	/*
  455|       |	 * Convert pseudo-headers from the byte order of
  456|       |	 * the host on which the file was saved to our
  457|       |	 * byte order, as necessary.
  458|       |	 */
  459|  33.4k|	switch (linktype) {
  ------------------
  |  Branch (459:10): [True: 866, False: 32.6k]
  ------------------
  460|       |
  461|  3.17k|	case DLT_PFLOG:
  ------------------
  |  |  367|  3.17k|#define DLT_PFLOG	117
  ------------------
  |  Branch (461:2): [True: 3.17k, False: 30.2k]
  ------------------
  462|  3.17k|		swap_pflog_header(hdr, data);
  463|  3.17k|		break;
  464|       |
  465|  6.68k|	case DLT_LINUX_SLL:
  ------------------
  |  |  347|  6.68k|#define DLT_LINUX_SLL	113
  ------------------
  |  Branch (465:2): [True: 6.68k, False: 26.7k]
  ------------------
  466|  6.68k|		swap_linux_sll_socketcan_header(hdr, data);
  467|  6.68k|		break;
  468|       |
  469|  2.56k|	case DLT_LINUX_SLL2:
  ------------------
  |  | 1510|  2.56k|#define DLT_LINUX_SLL2	276
  ------------------
  |  Branch (469:2): [True: 2.56k, False: 30.9k]
  ------------------
  470|  2.56k|		swap_linux_sll2_socketcan_header(hdr, data);
  471|  2.56k|		break;
  472|       |
  473|  5.11k|	case DLT_USB_LINUX:
  ------------------
  |  |  797|  5.11k|#define DLT_USB_LINUX		189
  ------------------
  |  Branch (473:2): [True: 5.11k, False: 28.3k]
  ------------------
  474|  5.11k|		swap_linux_usb_header(hdr, data, 0);
  475|  5.11k|		break;
  476|       |
  477|  11.7k|	case DLT_USB_LINUX_MMAPPED:
  ------------------
  |  | 1034|  11.7k|#define DLT_USB_LINUX_MMAPPED	220
  ------------------
  |  Branch (477:2): [True: 11.7k, False: 21.7k]
  ------------------
  478|  11.7k|		swap_linux_usb_header(hdr, data, 1);
  479|  11.7k|		break;
  480|       |
  481|  3.32k|	case DLT_NFLOG:
  ------------------
  |  | 1218|  3.32k|#define DLT_NFLOG		239
  ------------------
  |  Branch (481:2): [True: 3.32k, False: 30.1k]
  ------------------
  482|  3.32k|		swap_nflog_header(hdr, data);
  483|  3.32k|		break;
  484|  33.4k|	}
  485|  33.4k|}
pcap-util.c:swap_pflog_header:
   52|  3.17k|{
   53|  3.17k|	u_int caplen = hdr->caplen;
   54|  3.17k|	u_int length = hdr->len;
   55|  3.17k|	u_int pfloghdr_length;
   56|  3.17k|	struct pfloghdr *pflhdr = (struct pfloghdr *)buf;
   57|       |
   58|  3.17k|	if (caplen < (u_int) (offsetof(struct pfloghdr, uid) + sizeof pflhdr->uid) ||
  ------------------
  |  Branch (58:6): [True: 1.96k, False: 1.21k]
  ------------------
   59|  3.17k|	    length < (u_int) (offsetof(struct pfloghdr, uid) + sizeof pflhdr->uid)) {
  ------------------
  |  Branch (59:6): [True: 314, False: 901]
  ------------------
   60|       |		/* Not enough data to have the uid field */
   61|  2.27k|		return;
   62|  2.27k|	}
   63|       |
   64|    901|	pfloghdr_length = pflhdr->length;
   65|       |
   66|    901|	if (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, uid) + sizeof pflhdr->uid)) {
  ------------------
  |  Branch (66:6): [True: 580, False: 321]
  ------------------
   67|       |		/* Header doesn't include uid field */
   68|    580|		return;
   69|    580|	}
   70|    321|	pflhdr->uid = SWAPLONG(pflhdr->uid);
  ------------------
  |  |   54|    321|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    321|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    321|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    321|     ((((u_int)(y))>>24)&0xff))
  ------------------
   71|       |
   72|    321|	if (caplen < (u_int) (offsetof(struct pfloghdr, pid) + sizeof pflhdr->pid) ||
  ------------------
  |  Branch (72:6): [True: 67, False: 254]
  ------------------
   73|    321|	    length < (u_int) (offsetof(struct pfloghdr, pid) + sizeof pflhdr->pid)) {
  ------------------
  |  Branch (73:6): [True: 44, False: 210]
  ------------------
   74|       |		/* Not enough data to have the pid field */
   75|    111|		return;
   76|    111|	}
   77|    210|	if (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, pid) + sizeof pflhdr->pid)) {
  ------------------
  |  Branch (77:6): [True: 16, False: 194]
  ------------------
   78|       |		/* Header doesn't include pid field */
   79|     16|		return;
   80|     16|	}
   81|    194|	pflhdr->pid = SWAPLONG(pflhdr->pid);
  ------------------
  |  |   54|    194|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    194|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    194|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    194|     ((((u_int)(y))>>24)&0xff))
  ------------------
   82|       |
   83|    194|	if (caplen < (u_int) (offsetof(struct pfloghdr, rule_uid) + sizeof pflhdr->rule_uid) ||
  ------------------
  |  Branch (83:6): [True: 18, False: 176]
  ------------------
   84|    194|	    length < (u_int) (offsetof(struct pfloghdr, rule_uid) + sizeof pflhdr->rule_uid)) {
  ------------------
  |  Branch (84:6): [True: 26, False: 150]
  ------------------
   85|       |		/* Not enough data to have the rule_uid field */
   86|     44|		return;
   87|     44|	}
   88|    150|	if (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, rule_uid) + sizeof pflhdr->rule_uid)) {
  ------------------
  |  Branch (88:6): [True: 18, False: 132]
  ------------------
   89|       |		/* Header doesn't include rule_uid field */
   90|     18|		return;
   91|     18|	}
   92|    132|	pflhdr->rule_uid = SWAPLONG(pflhdr->rule_uid);
  ------------------
  |  |   54|    132|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    132|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    132|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    132|     ((((u_int)(y))>>24)&0xff))
  ------------------
   93|       |
   94|    132|	if (caplen < (u_int) (offsetof(struct pfloghdr, rule_pid) + sizeof pflhdr->rule_pid) ||
  ------------------
  |  Branch (94:6): [True: 18, False: 114]
  ------------------
   95|    132|	    length < (u_int) (offsetof(struct pfloghdr, rule_pid) + sizeof pflhdr->rule_pid)) {
  ------------------
  |  Branch (95:6): [True: 10, False: 104]
  ------------------
   96|       |		/* Not enough data to have the rule_pid field */
   97|     28|		return;
   98|     28|	}
   99|    104|	if (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, rule_pid) + sizeof pflhdr->rule_pid)) {
  ------------------
  |  Branch (99:6): [True: 10, False: 94]
  ------------------
  100|       |		/* Header doesn't include rule_pid field */
  101|     10|		return;
  102|     10|	}
  103|     94|	pflhdr->rule_pid = SWAPLONG(pflhdr->rule_pid);
  ------------------
  |  |   54|     94|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|     94|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|     94|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|     94|     ((((u_int)(y))>>24)&0xff))
  ------------------
  104|     94|}
pcap-util.c:swap_linux_sll_socketcan_header:
  191|  6.68k|{
  192|  6.68k|	u_int caplen = hdr->caplen;
  193|  6.68k|	u_int length = hdr->len;
  194|  6.68k|	struct sll_header *shdr = (struct sll_header *)buf;
  195|       |
  196|  6.68k|	if (caplen < (u_int) sizeof(struct sll_header) ||
  ------------------
  |  Branch (196:6): [True: 804, False: 5.88k]
  ------------------
  197|  6.68k|	    length < (u_int) sizeof(struct sll_header)) {
  ------------------
  |  Branch (197:6): [True: 411, False: 5.47k]
  ------------------
  198|       |		/* Not enough data to have the protocol field */
  199|  1.21k|		return;
  200|  1.21k|	}
  201|       |
  202|       |	/*
  203|       |	 * Byte-swap what needs to be byte-swapped.
  204|       |	 */
  205|  5.47k|	swap_socketcan_header(EXTRACT_BE_U_2(&shdr->sll_protocol),
  206|  5.47k|	    caplen - (u_int) sizeof(struct sll_header),
  207|  5.47k|	    length - (u_int) sizeof(struct sll_header),
  208|  5.47k|	    buf + sizeof(struct sll_header));
  209|  5.47k|}
pcap-util.c:swap_socketcan_header:
  124|  7.40k|{
  125|  7.40k|	pcap_can_socketcan_hdr *hdrp;
  126|  7.40k|	pcap_can_socketcan_xl_hdr *xl_hdrp;
  127|       |
  128|  7.40k|	switch (protocol) {
  129|       |
  130|    124|	case LINUX_SLL_P_CAN:
  ------------------
  |  |  142|    124|#define LINUX_SLL_P_CAN		0x000C	/* CAN frames, with SocketCAN pseudo-headers */
  ------------------
  |  Branch (130:2): [True: 124, False: 7.28k]
  ------------------
  131|    642|	case LINUX_SLL_P_CANFD:
  ------------------
  |  |  143|    642|#define LINUX_SLL_P_CANFD	0x000D	/* CAN FD frames, with SocketCAN pseudo-headers */
  ------------------
  |  Branch (131:2): [True: 518, False: 6.88k]
  ------------------
  132|       |		/*
  133|       |		 * CAN classic/CAN FD packet; fix up the packet's header
  134|       |		 * by byte-swapping the CAN ID field.
  135|       |		 */
  136|    642|		hdrp = (pcap_can_socketcan_hdr *)buf;
  137|    642|		if (caplen < (u_int) (offsetof(pcap_can_socketcan_hdr, can_id) + sizeof hdrp->can_id) ||
  ------------------
  |  Branch (137:7): [True: 200, False: 442]
  ------------------
  138|    642|		    length < (u_int) (offsetof(pcap_can_socketcan_hdr, can_id) + sizeof hdrp->can_id)) {
  ------------------
  |  Branch (138:7): [True: 50, False: 392]
  ------------------
  139|       |			/* Not enough data to have the can_id field */
  140|    250|			return;
  141|    250|		}
  142|    392|		hdrp->can_id = SWAPLONG(hdrp->can_id);
  ------------------
  |  |   54|    392|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    392|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    392|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    392|     ((((u_int)(y))>>24)&0xff))
  ------------------
  143|    392|		break;
  144|       |
  145|    634|	case LINUX_SLL_P_CANXL:
  ------------------
  |  |  144|    634|#define LINUX_SLL_P_CANXL	0x000E	/* CAN XL frames, with SocketCAN pseudo-headers */
  ------------------
  |  Branch (145:2): [True: 634, False: 6.77k]
  ------------------
  146|       |		/*
  147|       |		 * CAN XL packet; fix up the packet's header by
  148|       |		 * byte-swapping the priority/VCID field, the
  149|       |		 * payload length, and the acceptance field.
  150|       |		 */
  151|    634|		xl_hdrp = (pcap_can_socketcan_xl_hdr *)buf;
  152|    634|		if (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, priority_vcid) + sizeof xl_hdrp->priority_vcid) ||
  ------------------
  |  Branch (152:7): [True: 158, False: 476]
  ------------------
  153|    634|		    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, priority_vcid) + sizeof xl_hdrp->priority_vcid)) {
  ------------------
  |  Branch (153:7): [True: 49, False: 427]
  ------------------
  154|       |			/* Not enough data to have the priority_vcid field */
  155|    207|			return;
  156|    207|		}
  157|    427|		xl_hdrp->priority_vcid = SWAPLONG(xl_hdrp->priority_vcid);
  ------------------
  |  |   54|    427|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    427|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    427|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    427|     ((((u_int)(y))>>24)&0xff))
  ------------------
  158|    427|		if (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, payload_length) + sizeof xl_hdrp->payload_length) ||
  ------------------
  |  Branch (158:7): [True: 132, False: 295]
  ------------------
  159|    427|		    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, payload_length) + sizeof xl_hdrp->payload_length)) {
  ------------------
  |  Branch (159:7): [True: 28, False: 267]
  ------------------
  160|       |			/* Not enough data to have the payload_length field */
  161|    160|			return;
  162|    160|		}
  163|    267|		xl_hdrp->payload_length = SWAPSHORT(xl_hdrp->payload_length);
  ------------------
  |  |   59|    267|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|    267|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  164|    267|		if (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, acceptance_field) + sizeof xl_hdrp->acceptance_field) ||
  ------------------
  |  Branch (164:7): [True: 103, False: 164]
  ------------------
  165|    267|		    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, acceptance_field) + sizeof xl_hdrp->acceptance_field)) {
  ------------------
  |  Branch (165:7): [True: 28, False: 136]
  ------------------
  166|       |			/* Not enough data to have the acceptance_field field */
  167|    131|			return;
  168|    131|		}
  169|    136|		xl_hdrp->acceptance_field = SWAPLONG(xl_hdrp->acceptance_field);
  ------------------
  |  |   54|    136|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    136|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    136|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    136|     ((((u_int)(y))>>24)&0xff))
  ------------------
  170|    136|		break;
  171|       |
  172|  6.12k|	default:
  ------------------
  |  Branch (172:2): [True: 6.12k, False: 1.27k]
  ------------------
  173|       |		/*
  174|       |		 * Not a CAN packet; nothing to do.
  175|       |		 */
  176|  6.12k|		break;
  177|  7.40k|	}
  178|  7.40k|}
pcap-util.c:swap_linux_sll2_socketcan_header:
  216|  2.56k|{
  217|  2.56k|	u_int caplen = hdr->caplen;
  218|  2.56k|	u_int length = hdr->len;
  219|  2.56k|	struct sll2_header *shdr = (struct sll2_header *)buf;
  220|       |
  221|  2.56k|	if (caplen < (u_int) sizeof(struct sll2_header) ||
  ------------------
  |  Branch (221:6): [True: 473, False: 2.08k]
  ------------------
  222|  2.56k|	    length < (u_int) sizeof(struct sll2_header)) {
  ------------------
  |  Branch (222:6): [True: 157, False: 1.93k]
  ------------------
  223|       |		/* Not enough data to have the protocol field */
  224|    630|		return;
  225|    630|	}
  226|       |
  227|       |	/*
  228|       |	 * Byte-swap what needs to be byte-swapped.
  229|       |	 */
  230|  1.93k|	swap_socketcan_header(EXTRACT_BE_U_2(&shdr->sll2_protocol),
  231|  1.93k|	    caplen - (u_int) sizeof(struct sll2_header),
  232|  1.93k|	    length - (u_int) sizeof(struct sll2_header),
  233|  1.93k|	    buf + sizeof(struct sll2_header));
  234|  1.93k|}
pcap-util.c:swap_linux_usb_header:
  248|  16.8k|{
  249|  16.8k|	pcap_usb_header_mmapped *uhdr = (pcap_usb_header_mmapped *)buf;
  250|  16.8k|	bpf_u_int32 offset = 0;
  251|       |
  252|       |	/*
  253|       |	 * "offset" is the offset *past* the field we're swapping;
  254|       |	 * we skip the field *before* checking to make sure
  255|       |	 * the captured data length includes the entire field.
  256|       |	 */
  257|       |
  258|       |	/*
  259|       |	 * The URB id is a totally opaque value; do we really need to
  260|       |	 * convert it to the reading host's byte order???
  261|       |	 */
  262|  16.8k|	offset += 8;			/* skip past id */
  263|  16.8k|	if (hdr->caplen < offset)
  ------------------
  |  Branch (263:6): [True: 3.89k, False: 12.9k]
  ------------------
  264|  3.89k|		return;
  265|  12.9k|	uhdr->id = SWAPLL(uhdr->id);
  ------------------
  |  |   45|  12.9k|#define SWAPLL(y)  ((((uint64_t)(y) & 0xff00000000000000ULL) >> 56) | \
  |  |   46|  12.9k|                      (((uint64_t)(y) & 0x00ff000000000000ULL) >> 40) | \
  |  |   47|  12.9k|                      (((uint64_t)(y) & 0x0000ff0000000000ULL) >> 24) | \
  |  |   48|  12.9k|                      (((uint64_t)(y) & 0x000000ff00000000ULL) >> 8)  | \
  |  |   49|  12.9k|                      (((uint64_t)(y) & 0x00000000ff000000ULL) << 8)  | \
  |  |   50|  12.9k|                      (((uint64_t)(y) & 0x0000000000ff0000ULL) << 24) | \
  |  |   51|  12.9k|                      (((uint64_t)(y) & 0x000000000000ff00ULL) << 40) | \
  |  |   52|  12.9k|                      (((uint64_t)(y) & 0x00000000000000ffULL) << 56))
  ------------------
  266|       |
  267|  12.9k|	offset += 4;			/* skip past various 1-byte fields */
  268|       |
  269|  12.9k|	offset += 2;			/* skip past bus_id */
  270|  12.9k|	if (hdr->caplen < offset)
  ------------------
  |  Branch (270:6): [True: 388, False: 12.5k]
  ------------------
  271|    388|		return;
  272|  12.5k|	uhdr->bus_id = SWAPSHORT(uhdr->bus_id);
  ------------------
  |  |   59|  12.5k|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|  12.5k|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  273|       |
  274|  12.5k|	offset += 2;			/* skip past various 1-byte fields */
  275|       |
  276|  12.5k|	offset += 8;			/* skip past ts_sec */
  277|  12.5k|	if (hdr->caplen < offset)
  ------------------
  |  Branch (277:6): [True: 801, False: 11.7k]
  ------------------
  278|    801|		return;
  279|  11.7k|	uhdr->ts_sec = SWAPLL(uhdr->ts_sec);
  ------------------
  |  |   45|  11.7k|#define SWAPLL(y)  ((((uint64_t)(y) & 0xff00000000000000ULL) >> 56) | \
  |  |   46|  11.7k|                      (((uint64_t)(y) & 0x00ff000000000000ULL) >> 40) | \
  |  |   47|  11.7k|                      (((uint64_t)(y) & 0x0000ff0000000000ULL) >> 24) | \
  |  |   48|  11.7k|                      (((uint64_t)(y) & 0x000000ff00000000ULL) >> 8)  | \
  |  |   49|  11.7k|                      (((uint64_t)(y) & 0x00000000ff000000ULL) << 8)  | \
  |  |   50|  11.7k|                      (((uint64_t)(y) & 0x0000000000ff0000ULL) << 24) | \
  |  |   51|  11.7k|                      (((uint64_t)(y) & 0x000000000000ff00ULL) << 40) | \
  |  |   52|  11.7k|                      (((uint64_t)(y) & 0x00000000000000ffULL) << 56))
  ------------------
  280|       |
  281|  11.7k|	offset += 4;			/* skip past ts_usec */
  282|  11.7k|	if (hdr->caplen < offset)
  ------------------
  |  Branch (282:6): [True: 393, False: 11.3k]
  ------------------
  283|    393|		return;
  284|  11.3k|	uhdr->ts_usec = SWAPLONG(uhdr->ts_usec);
  ------------------
  |  |   54|  11.3k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  11.3k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  11.3k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  11.3k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  285|       |
  286|  11.3k|	offset += 4;			/* skip past status */
  287|  11.3k|	if (hdr->caplen < offset)
  ------------------
  |  Branch (287:6): [True: 3.43k, False: 7.94k]
  ------------------
  288|  3.43k|		return;
  289|  7.94k|	uhdr->status = SWAPLONG(uhdr->status);
  ------------------
  |  |   54|  7.94k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  7.94k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  7.94k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  7.94k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  290|       |
  291|  7.94k|	offset += 4;			/* skip past urb_len */
  292|  7.94k|	if (hdr->caplen < offset)
  ------------------
  |  Branch (292:6): [True: 2.24k, False: 5.70k]
  ------------------
  293|  2.24k|		return;
  294|  5.70k|	uhdr->urb_len = SWAPLONG(uhdr->urb_len);
  ------------------
  |  |   54|  5.70k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  5.70k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  5.70k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  5.70k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  295|       |
  296|  5.70k|	offset += 4;			/* skip past data_len */
  297|  5.70k|	if (hdr->caplen < offset)
  ------------------
  |  Branch (297:6): [True: 390, False: 5.31k]
  ------------------
  298|    390|		return;
  299|  5.31k|	uhdr->data_len = SWAPLONG(uhdr->data_len);
  ------------------
  |  |   54|  5.31k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  5.31k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  5.31k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  5.31k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  300|       |
  301|  5.31k|	if (uhdr->transfer_type == URB_ISOCHRONOUS) {
  ------------------
  |  |   43|  5.31k|#define URB_ISOCHRONOUS   0x0
  ------------------
  |  Branch (301:6): [True: 3.19k, False: 2.11k]
  ------------------
  302|  3.19k|		offset += 4;			/* skip past s.iso.error_count */
  303|  3.19k|		if (hdr->caplen < offset)
  ------------------
  |  Branch (303:7): [True: 391, False: 2.80k]
  ------------------
  304|    391|			return;
  305|  2.80k|		uhdr->s.iso.error_count = SWAPLONG(uhdr->s.iso.error_count);
  ------------------
  |  |   54|  2.80k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  2.80k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  2.80k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  2.80k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  306|       |
  307|  2.80k|		offset += 4;			/* skip past s.iso.numdesc */
  308|  2.80k|		if (hdr->caplen < offset)
  ------------------
  |  Branch (308:7): [True: 344, False: 2.46k]
  ------------------
  309|    344|			return;
  310|  2.46k|		uhdr->s.iso.numdesc = SWAPLONG(uhdr->s.iso.numdesc);
  ------------------
  |  |   54|  2.46k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  2.46k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  2.46k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  2.46k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  311|  2.46k|	} else
  312|  2.11k|		offset += 8;			/* skip USB setup header */
  313|       |
  314|       |	/*
  315|       |	 * With the old header, there are no isochronous descriptors
  316|       |	 * after the header.
  317|       |	 *
  318|       |	 * With the new header, the actual number of descriptors in
  319|       |	 * the header is not s.iso.numdesc, it's ndesc - only the
  320|       |	 * first N descriptors, for some value of N, are put into
  321|       |	 * the header, and ndesc is set to the actual number copied.
  322|       |	 * In addition, if s.iso.numdesc is negative, no descriptors
  323|       |	 * are captured, and ndesc is set to 0.
  324|       |	 */
  325|  4.57k|	if (header_len_64_bytes) {
  ------------------
  |  Branch (325:6): [True: 3.59k, False: 981]
  ------------------
  326|       |		/*
  327|       |		 * This is either the "version 1" header, with
  328|       |		 * 16 bytes of additional fields at the end, or
  329|       |		 * a "version 0" header from a memory-mapped
  330|       |		 * capture, with 16 bytes of zeroed-out padding
  331|       |		 * at the end.  Byte swap them as if this were
  332|       |		 * a "version 1" header.
  333|       |		 */
  334|  3.59k|		offset += 4;			/* skip past interval */
  335|  3.59k|		if (hdr->caplen < offset)
  ------------------
  |  Branch (335:7): [True: 1.35k, False: 2.24k]
  ------------------
  336|  1.35k|			return;
  337|  2.24k|		uhdr->interval = SWAPLONG(uhdr->interval);
  ------------------
  |  |   54|  2.24k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  2.24k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  2.24k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  2.24k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  338|       |
  339|  2.24k|		offset += 4;			/* skip past start_frame */
  340|  2.24k|		if (hdr->caplen < offset)
  ------------------
  |  Branch (340:7): [True: 195, False: 2.04k]
  ------------------
  341|    195|			return;
  342|  2.04k|		uhdr->start_frame = SWAPLONG(uhdr->start_frame);
  ------------------
  |  |   54|  2.04k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  2.04k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  2.04k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  2.04k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  343|       |
  344|  2.04k|		offset += 4;			/* skip past xfer_flags */
  345|  2.04k|		if (hdr->caplen < offset)
  ------------------
  |  Branch (345:7): [True: 112, False: 1.93k]
  ------------------
  346|    112|			return;
  347|  1.93k|		uhdr->xfer_flags = SWAPLONG(uhdr->xfer_flags);
  ------------------
  |  |   54|  1.93k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  1.93k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  1.93k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  1.93k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  348|       |
  349|  1.93k|		offset += 4;			/* skip past ndesc */
  350|  1.93k|		if (hdr->caplen < offset)
  ------------------
  |  Branch (350:7): [True: 216, False: 1.71k]
  ------------------
  351|    216|			return;
  352|  1.71k|		uhdr->ndesc = SWAPLONG(uhdr->ndesc);
  ------------------
  |  |   54|  1.71k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  1.71k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  1.71k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  1.71k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  353|       |
  354|  1.71k|		if (uhdr->transfer_type == URB_ISOCHRONOUS) {
  ------------------
  |  |   43|  1.71k|#define URB_ISOCHRONOUS   0x0
  ------------------
  |  Branch (354:7): [True: 1.48k, False: 235]
  ------------------
  355|       |			/* swap the values in struct linux_usb_isodesc */
  356|  1.48k|			usb_isodesc *pisodesc;
  357|  1.48k|			uint32_t i;
  358|       |
  359|  1.48k|			pisodesc = (usb_isodesc *)(void *)(buf+offset);
  360|  7.13k|			for (i = 0; i < uhdr->ndesc; i++) {
  ------------------
  |  Branch (360:16): [True: 6.28k, False: 853]
  ------------------
  361|  6.28k|				offset += 4;		/* skip past status */
  362|  6.28k|				if (hdr->caplen < offset)
  ------------------
  |  Branch (362:9): [True: 333, False: 5.95k]
  ------------------
  363|    333|					return;
  364|  5.95k|				pisodesc->status = SWAPLONG(pisodesc->status);
  ------------------
  |  |   54|  5.95k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  5.95k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  5.95k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  5.95k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  365|       |
  366|  5.95k|				offset += 4;		/* skip past offset */
  367|  5.95k|				if (hdr->caplen < offset)
  ------------------
  |  Branch (367:9): [True: 127, False: 5.82k]
  ------------------
  368|    127|					return;
  369|  5.82k|				pisodesc->offset = SWAPLONG(pisodesc->offset);
  ------------------
  |  |   54|  5.82k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  5.82k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  5.82k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  5.82k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  370|       |
  371|  5.82k|				offset += 4;		/* skip past len */
  372|  5.82k|				if (hdr->caplen < offset)
  ------------------
  |  Branch (372:9): [True: 171, False: 5.65k]
  ------------------
  373|    171|					return;
  374|  5.65k|				pisodesc->len = SWAPLONG(pisodesc->len);
  ------------------
  |  |   54|  5.65k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  5.65k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  5.65k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  5.65k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  375|       |
  376|  5.65k|				offset += 4;		/* skip past padding */
  377|       |
  378|  5.65k|				pisodesc++;
  379|  5.65k|			}
  380|  1.48k|		}
  381|  1.71k|	}
  382|  4.57k|}
pcap-util.c:swap_nflog_header:
  397|  3.32k|{
  398|  3.32k|	u_char *p = buf;
  399|  3.32k|	nflog_hdr_t *nfhdr = (nflog_hdr_t *)buf;
  400|  3.32k|	nflog_tlv_t *tlv;
  401|  3.32k|	u_int caplen = hdr->caplen;
  402|  3.32k|	u_int length = hdr->len;
  403|  3.32k|	u_int size;
  404|       |
  405|  3.32k|	if (caplen < (u_int) sizeof(nflog_hdr_t) ||
  ------------------
  |  Branch (405:6): [True: 704, False: 2.62k]
  ------------------
  406|  3.32k|	    length < (u_int) sizeof(nflog_hdr_t)) {
  ------------------
  |  Branch (406:6): [True: 274, False: 2.34k]
  ------------------
  407|       |		/* Not enough data to have any TLVs. */
  408|    978|		return;
  409|    978|	}
  410|       |
  411|  2.34k|	if (nfhdr->nflog_version != 0) {
  ------------------
  |  Branch (411:6): [True: 1.06k, False: 1.27k]
  ------------------
  412|       |		/* Unknown NFLOG version */
  413|  1.06k|		return;
  414|  1.06k|	}
  415|       |
  416|  1.27k|	length -= sizeof(nflog_hdr_t);
  417|  1.27k|	caplen -= sizeof(nflog_hdr_t);
  418|  1.27k|	p += sizeof(nflog_hdr_t);
  419|       |
  420|  2.00k|	while (caplen >= sizeof(nflog_tlv_t)) {
  ------------------
  |  Branch (420:9): [True: 1.53k, False: 467]
  ------------------
  421|  1.53k|		tlv = (nflog_tlv_t *) p;
  422|       |
  423|       |		/* Swap the type and length. */
  424|  1.53k|		tlv->tlv_type = SWAPSHORT(tlv->tlv_type);
  ------------------
  |  |   59|  1.53k|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|  1.53k|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  425|  1.53k|		tlv->tlv_length = SWAPSHORT(tlv->tlv_length);
  ------------------
  |  |   59|  1.53k|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|  1.53k|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  426|       |
  427|       |		/* Get the length of the TLV. */
  428|  1.53k|		size = tlv->tlv_length;
  429|  1.53k|		if (size % 4 != 0)
  ------------------
  |  Branch (429:7): [True: 693, False: 845]
  ------------------
  430|    693|			size += 4 - size % 4;
  431|       |
  432|       |		/* Is the TLV's length less than the minimum? */
  433|  1.53k|		if (size < sizeof(nflog_tlv_t)) {
  ------------------
  |  Branch (433:7): [True: 125, False: 1.41k]
  ------------------
  434|       |			/* Yes. Give up now. */
  435|    125|			return;
  436|    125|		}
  437|       |
  438|       |		/* Do we have enough data for the full TLV? */
  439|  1.41k|		if (caplen < size || length < size) {
  ------------------
  |  Branch (439:7): [True: 687, False: 726]
  |  Branch (439:24): [True: 0, False: 726]
  ------------------
  440|       |			/* No. */
  441|    687|			return;
  442|    687|		}
  443|       |
  444|       |		/* Skip over the TLV. */
  445|    726|		length -= size;
  446|    726|		caplen -= size;
  447|    726|		p += size;
  448|    726|	}
  449|  1.27k|}
pcap-util.c:packet_length_might_be_wrong:
  490|     71|{
  491|     71|	uint32_t old_style_packet_length;
  492|       |
  493|       |	/*
  494|       |	 * Calculate the packet length the old way.
  495|       |	 * We know that the multiplication won't overflow, but
  496|       |	 * we don't know that the additions won't.  Calculate
  497|       |	 * it with no overflow checks, as that's how it
  498|       |	 * would have been calculated when it was captured.
  499|       |	 */
  500|     71|	old_style_packet_length = iso_pseudo_header_len(usb_hdr) +
  501|     71|	    usb_hdr->urb_len;
  502|     71|	return (hdr->len == old_style_packet_length);
  503|     71|}

pcapint_oneshot:
  546|  49.1k|{
  547|  49.1k|	struct oneshot_userdata *sp = (struct oneshot_userdata *)user;
  548|       |
  549|  49.1k|	*sp->hdr = *h;
  550|  49.1k|	*sp->pkt = pkt;
  551|  49.1k|}
pcap_next_ex:
  570|  51.0k|{
  571|  51.0k|	struct oneshot_userdata s;
  572|       |
  573|  51.0k|	s.hdr = &p->pcap_header;
  574|  51.0k|	s.pkt = pkt_data;
  575|  51.0k|	s.pd = p;
  576|       |
  577|       |	/* Saves a pointer to the packet headers */
  578|  51.0k|	*pkt_header= &p->pcap_header;
  579|       |
  580|  51.0k|	if (p->rfile != NULL) {
  ------------------
  |  Branch (580:6): [True: 51.0k, False: 0]
  ------------------
  581|  51.0k|		int status;
  582|       |
  583|       |		/* We are on an offline capture */
  584|  51.0k|		status = pcapint_offline_read(p, 1, p->oneshot_callback,
  585|  51.0k|		    (u_char *)&s);
  586|       |
  587|       |		/*
  588|       |		 * Return codes for pcapint_offline_read() are:
  589|       |		 *   -  0: EOF
  590|       |		 *   - -1: error
  591|       |		 *   - >0: OK - result is number of packets read, so
  592|       |		 *         it will be 1 in this case, as we've passed
  593|       |		 *         a maximum packet count of 1
  594|       |		 * The first one ('0') conflicts with the return code of
  595|       |		 * 0 from pcap_read() meaning "no packets arrived before
  596|       |		 * the timeout expired", so we map it to -2 so you can
  597|       |		 * distinguish between an EOF from a savefile and a
  598|       |		 * "no packets arrived before the timeout expired, try
  599|       |		 * again" from a live capture.
  600|       |		 */
  601|  51.0k|		if (status == 0)
  ------------------
  |  Branch (601:7): [True: 1.22k, False: 49.8k]
  ------------------
  602|  1.22k|			return (-2);
  603|  49.8k|		else
  604|  49.8k|			return (status);
  605|  51.0k|	}
  606|       |
  607|       |	/*
  608|       |	 * Return codes for pcap_read() are:
  609|       |	 *   -  0: timeout
  610|       |	 *   - -1: error
  611|       |	 *   - -2: loop was broken out of with pcap_breakloop()
  612|       |	 *   - >0: OK, result is number of packets captured, so
  613|       |	 *         it will be 1 in this case, as we've passed
  614|       |	 *         a maximum packet count of 1
  615|       |	 * The first one ('0') conflicts with the return code of 0 from
  616|       |	 * pcapint_offline_read() meaning "end of file".
  617|       |	*/
  618|      0|	return (p->read_op(p, 1, p->oneshot_callback, (u_char *)&s));
  619|  51.0k|}
pcapint_open_offline_common:
 2880|  1.95k|{
 2881|  1.95k|	pcap_t *p;
 2882|       |
 2883|  1.95k|	p = pcap_alloc_pcap_t(ebuf, total_size, private_offset);
 2884|  1.95k|	if (p == NULL)
  ------------------
  |  Branch (2884:6): [True: 0, False: 1.95k]
  ------------------
 2885|      0|		return (NULL);
 2886|       |
 2887|  1.95k|	p->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;
  ------------------
  |  |  537|  1.95k|#define PCAP_TSTAMP_PRECISION_MICRO	0	/* use timestamps with microsecond precision, default */
  ------------------
 2888|       |
 2889|  1.95k|	return (p);
 2890|  1.95k|}
pcap_stats:
 3828|  1.89k|{
 3829|  1.89k|	return (p->stats_op(p, ps));
 3830|  1.89k|}
pcap_close:
 4157|  1.89k|{
 4158|  1.89k|	p->cleanup_op(p);
 4159|  1.89k|	free(p);
 4160|  1.89k|}
pcap.c:pcap_alloc_pcap_t:
 2430|  1.95k|{
 2431|  1.95k|	char *chunk;
 2432|  1.95k|	pcap_t *p;
 2433|       |
 2434|       |	/*
 2435|       |	 * total_size is the size of a structure containing a pcap_t
 2436|       |	 * followed by a private structure.
 2437|       |	 */
 2438|  1.95k|	chunk = calloc(total_size, 1);
 2439|  1.95k|	if (chunk == NULL) {
  ------------------
  |  Branch (2439:6): [True: 0, False: 1.95k]
  ------------------
 2440|      0|		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
 2441|      0|		    errno, "malloc");
 2442|      0|		return (NULL);
 2443|      0|	}
 2444|       |
 2445|       |	/*
 2446|       |	 * Get a pointer to the pcap_t at the beginning.
 2447|       |	 */
 2448|  1.95k|	p = (pcap_t *)chunk;
 2449|       |
 2450|       |#ifdef _WIN32
 2451|       |	p->handle = INVALID_HANDLE_VALUE;	/* not opened yet */
 2452|       |#else /* _WIN32 */
 2453|  1.95k|	p->fd = -1;	/* not opened yet */
 2454|  1.95k|	p->selectable_fd = -1;
 2455|  1.95k|	p->required_select_timeout = NULL;
 2456|  1.95k|#endif /* _WIN32 */
 2457|       |
 2458|       |	/*
 2459|       |	 * private_offset is the offset, in bytes, of the private
 2460|       |	 * data from the beginning of the structure.
 2461|       |	 *
 2462|       |	 * Set the pointer to the private data; that's private_offset
 2463|       |	 * bytes past the pcap_t.
 2464|       |	 */
 2465|  1.95k|	p->priv = (void *)(chunk + private_offset);
 2466|       |
 2467|  1.95k|	return (p);
 2468|  1.95k|}

pcapint_sf_cleanup:
  238|  1.89k|{
  239|  1.89k|	if (p->rfile != stdin)
  ------------------
  |  Branch (239:6): [True: 1.89k, False: 0]
  ------------------
  240|  1.89k|		(void)fclose(p->rfile);
  241|  1.89k|	if (p->buffer != NULL)
  ------------------
  |  Branch (241:6): [True: 1.89k, False: 0]
  ------------------
  242|  1.89k|		free(p->buffer);
  243|  1.89k|	pcap_freecode(&p->fcode);
  244|  1.89k|}
pcap_open_offline_with_tstamp_precision:
  337|  2.72k|{
  338|  2.72k|	FILE *fp;
  339|  2.72k|	pcap_t *p;
  340|       |
  341|  2.72k|	if (fname == NULL) {
  ------------------
  |  Branch (341:6): [True: 0, False: 2.72k]
  ------------------
  342|      0|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  343|      0|		    "A null pointer was supplied as the file name");
  344|      0|		return (NULL);
  345|      0|	}
  346|  2.72k|	if (fname[0] == '-' && fname[1] == '\0')
  ------------------
  |  Branch (346:6): [True: 0, False: 2.72k]
  |  Branch (346:25): [True: 0, False: 0]
  ------------------
  347|      0|	{
  348|      0|		fp = stdin;
  349|      0|		if (fp == NULL) {
  ------------------
  |  Branch (349:7): [True: 0, False: 0]
  ------------------
  350|      0|			snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  351|      0|			    "The standard input is not open");
  352|      0|			return (NULL);
  353|      0|		}
  354|       |#if defined(_WIN32)
  355|       |		/*
  356|       |		 * We're reading from the standard input, so put it in binary
  357|       |		 * mode, as savefiles are binary files.
  358|       |		 */
  359|       |		SET_BINMODE(fp);
  360|       |#endif
  361|      0|	}
  362|  2.72k|	else {
  363|       |		/*
  364|       |		 * Use pcapint_charset_fopen(); on Windows, it tests whether we're
  365|       |		 * in "local code page" or "UTF-8" mode, and treats the
  366|       |		 * pathname appropriately, and on other platforms, it just
  367|       |		 * wraps fopen().
  368|       |		 *
  369|       |		 * "b" is supported as of C90, so *all* UN*Xes should
  370|       |		 * support it, even though it does nothing.
  371|       |		 */
  372|  2.72k|		fp = pcapint_charset_fopen(fname, "rb");
  ------------------
  |  |  527|  2.72k|#define pcapint_charset_fopen(path, mode)	fopen((path), (mode))
  ------------------
  373|  2.72k|		if (fp == NULL) {
  ------------------
  |  Branch (373:7): [True: 0, False: 2.72k]
  ------------------
  374|      0|			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  375|      0|			    errno, "%s", fname);
  376|      0|			return (NULL);
  377|      0|		}
  378|  2.72k|	}
  379|  2.72k|	p = pcap_fopen_offline_with_tstamp_precision(fp, precision, errbuf);
  380|  2.72k|	if (p == NULL) {
  ------------------
  |  Branch (380:6): [True: 826, False: 1.89k]
  ------------------
  381|    826|		if (fp != stdin)
  ------------------
  |  Branch (381:7): [True: 826, False: 0]
  ------------------
  382|    826|			fclose(fp);
  383|    826|	}
  384|  2.72k|	return (p);
  385|  2.72k|}
pcap_open_offline:
  389|  2.72k|{
  390|  2.72k|	return (pcap_open_offline_with_tstamp_precision(fname,
  391|  2.72k|	    PCAP_TSTAMP_PRECISION_MICRO, errbuf));
  ------------------
  |  |  537|  2.72k|#define PCAP_TSTAMP_PRECISION_MICRO	0	/* use timestamps with microsecond precision, default */
  ------------------
  392|  2.72k|}
pcapint_adjust_snapshot:
  440|  3.15k|{
  441|  3.15k|	if (snaplen == 0 || snaplen > INT_MAX) {
  ------------------
  |  Branch (441:6): [True: 174, False: 2.98k]
  |  Branch (441:22): [True: 68, False: 2.91k]
  ------------------
  442|       |		/*
  443|       |		 * Bogus snapshot length; use the maximum for this
  444|       |		 * link-layer type as a fallback.
  445|       |		 *
  446|       |		 * XXX - we don't clamp snapshot lengths that are
  447|       |		 * <= INT_MAX but > max_snaplen_for_dlt(linktype),
  448|       |		 * so a capture file could cause us to allocate
  449|       |		 * a Really Big Buffer.
  450|       |		 */
  451|    242|		snaplen = max_snaplen_for_dlt(linktype);
  452|    242|	}
  453|  3.15k|	return snaplen;
  454|  3.15k|}
pcap_fopen_offline_with_tstamp_precision:
  469|  2.72k|{
  470|  2.72k|	register pcap_t *p;
  471|  2.72k|	uint8_t magic[4];
  472|  2.72k|	size_t amt_read;
  473|  2.72k|	u_int i;
  474|  2.72k|	int err;
  475|       |
  476|       |	/*
  477|       |	 * Fail if we were passed a NULL fp.
  478|       |	 *
  479|       |	 * That shouldn't happen if we're opening with a path name, but
  480|       |	 * it could happen if buggy code is opening with a FILE * and
  481|       |	 * didn't bother to make sure the FILE * isn't null.
  482|       |	 */
  483|  2.72k|	if (fp == NULL) {
  ------------------
  |  Branch (483:6): [True: 0, False: 2.72k]
  ------------------
  484|      0|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  485|      0|		    "Null FILE * pointer provided to savefile open routine");
  486|      0|		return (NULL);
  487|      0|	}
  488|       |
  489|       |	/*
  490|       |	 * Read the first 4 bytes of the file; the network analyzer dump
  491|       |	 * file formats we support (pcap and pcapng), and several other
  492|       |	 * formats we might support in the future (such as snoop, DOS and
  493|       |	 * Windows Sniffer, and Microsoft Network Monitor) all have magic
  494|       |	 * numbers that are unique in their first 4 bytes.
  495|       |	 */
  496|  2.72k|	amt_read = fread(&magic, 1, sizeof(magic), fp);
  497|  2.72k|	if (amt_read != sizeof(magic)) {
  ------------------
  |  Branch (497:6): [True: 1, False: 2.72k]
  ------------------
  498|      1|		if (ferror(fp)) {
  ------------------
  |  Branch (498:7): [True: 0, False: 1]
  ------------------
  499|      0|			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  500|      0|			    errno, "error reading dump file");
  501|      1|		} else {
  502|      1|			snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
  503|      1|			    "truncated dump file; tried to read %zu file header bytes, only got %zu",
  504|      1|			    sizeof(magic), amt_read);
  505|      1|		}
  506|      1|		return (NULL);
  507|      1|	}
  508|       |
  509|       |	/*
  510|       |	 * Try all file types.
  511|       |	 */
  512|  4.51k|	for (i = 0; i < N_FILE_TYPES; i++) {
  ------------------
  |  |  461|  4.51k|#define	N_FILE_TYPES	(sizeof check_headers / sizeof check_headers[0])
  ------------------
  |  Branch (512:14): [True: 3.75k, False: 760]
  ------------------
  513|  3.75k|		p = (*check_headers[i])(magic, fp, precision, errbuf, &err);
  514|  3.75k|		if (p != NULL) {
  ------------------
  |  Branch (514:7): [True: 1.89k, False: 1.85k]
  ------------------
  515|       |			/* Yup, that's it. */
  516|  1.89k|			goto found;
  517|  1.89k|		}
  518|  1.85k|		if (err) {
  ------------------
  |  Branch (518:7): [True: 65, False: 1.79k]
  ------------------
  519|       |			/*
  520|       |			 * Error trying to read the header.
  521|       |			 */
  522|     65|			return (NULL);
  523|     65|		}
  524|  1.85k|	}
  525|       |
  526|       |	/*
  527|       |	 * Well, who knows what this mess is....
  528|       |	 */
  529|    760|	snprintf(errbuf, PCAP_ERRBUF_SIZE, "unknown file format");
  ------------------
  |  |  149|    760|#define PCAP_ERRBUF_SIZE 256
  ------------------
  530|    760|	return (NULL);
  531|       |
  532|  1.89k|found:
  533|  1.89k|	p->rfile = fp;
  534|       |
  535|       |	/* Padding only needed for live capture fcode */
  536|  1.89k|	p->fddipad = 0;
  537|       |
  538|  1.89k|#if !defined(_WIN32)
  539|       |	/*
  540|       |	 * You can do "select()" and "poll()" on plain files on most
  541|       |	 * platforms, and should be able to do so on pipes.
  542|       |	 *
  543|       |	 * You can't do "select()" on anything other than sockets in
  544|       |	 * Windows, so, on Win32 systems, we don't have "selectable_fd".
  545|       |	 */
  546|  1.89k|	p->selectable_fd = fileno(fp);
  547|  1.89k|#endif
  548|       |
  549|  1.89k|	p->can_set_rfmon_op = sf_cant_set_rfmon;
  550|  1.89k|	p->read_op = pcapint_offline_read;
  551|  1.89k|	p->inject_op = sf_inject;
  552|  1.89k|	p->setfilter_op = pcapint_install_bpf_program;
  553|  1.89k|	p->setdirection_op = sf_setdirection;
  554|  1.89k|	p->set_datalink_op = NULL;	/* we don't support munging link-layer headers */
  555|  1.89k|	p->getnonblock_op = sf_getnonblock;
  556|  1.89k|	p->setnonblock_op = sf_setnonblock;
  557|  1.89k|	p->stats_op = sf_stats;
  558|       |#ifdef _WIN32
  559|       |	p->stats_ex_op = sf_stats_ex;
  560|       |	p->setbuff_op = sf_setbuff;
  561|       |	p->setmode_op = sf_setmode;
  562|       |	p->setmintocopy_op = sf_setmintocopy;
  563|       |	p->getevent_op = sf_getevent;
  564|       |	p->oid_get_request_op = sf_oid_get_request;
  565|       |	p->oid_set_request_op = sf_oid_set_request;
  566|       |	p->sendqueue_transmit_op = sf_sendqueue_transmit;
  567|       |	p->setuserbuffer_op = sf_setuserbuffer;
  568|       |	p->live_dump_op = sf_live_dump;
  569|       |	p->live_dump_ended_op = sf_live_dump_ended;
  570|       |#endif
  571|       |
  572|       |	/*
  573|       |	 * For offline captures, the standard one-shot callback can
  574|       |	 * be used for pcap_next()/pcap_next_ex().
  575|       |	 */
  576|  1.89k|	p->oneshot_callback = pcapint_oneshot;
  577|       |
  578|       |	/*
  579|       |	 * Default breakloop operation.
  580|       |	 */
  581|  1.89k|	p->breakloop_op = pcapint_breakloop_common;
  582|       |
  583|       |	/*
  584|       |	 * Savefiles never require special BPF code generation.
  585|       |	 */
  586|  1.89k|	p->bpf_codegen_flags = 0;
  587|       |
  588|  1.89k|	p->activated = 1;
  589|       |
  590|  1.89k|	return (p);
  591|  2.72k|}
pcapint_offline_read:
  614|  51.0k|{
  615|  51.0k|	struct bpf_insn *fcode;
  616|  51.0k|	int n = 0;
  617|  51.0k|	u_char *data;
  618|       |
  619|       |	/*
  620|       |	 * This can conceivably process more than INT_MAX packets,
  621|       |	 * which would overflow the packet count, causing it either
  622|       |	 * to look like a negative number, and thus cause us to
  623|       |	 * return a value that looks like an error, or overflow
  624|       |	 * back into positive territory, and thus cause us to
  625|       |	 * return a too-low count.
  626|       |	 *
  627|       |	 * Therefore, if the packet count is unlimited, we clip
  628|       |	 * it at INT_MAX; this routine is not expected to
  629|       |	 * process packets indefinitely, so that's not an issue.
  630|       |	 */
  631|  51.0k|	if (PACKET_COUNT_IS_UNLIMITED(cnt))
  ------------------
  |  |  388|  51.0k|#define PACKET_COUNT_IS_UNLIMITED(count)	((count) <= 0)
  |  |  ------------------
  |  |  |  Branch (388:42): [True: 0, False: 51.0k]
  |  |  ------------------
  ------------------
  632|      0|		cnt = INT_MAX;
  633|       |
  634|  51.0k|	for (;;) {
  635|  51.0k|		struct pcap_pkthdr h;
  636|  51.0k|		int status;
  637|       |
  638|       |		/*
  639|       |		 * Has "pcap_breakloop()" been called?
  640|       |		 * If so, return immediately - if we haven't read any
  641|       |		 * packets, clear the flag and return -2 to indicate
  642|       |		 * that we were told to break out of the loop, otherwise
  643|       |		 * leave the flag set, so that the *next* call will break
  644|       |		 * out of the loop without having read any packets, and
  645|       |		 * return the number of packets we've processed so far.
  646|       |		 */
  647|  51.0k|		if (p->break_loop) {
  ------------------
  |  Branch (647:7): [True: 0, False: 51.0k]
  ------------------
  648|      0|			if (n == 0) {
  ------------------
  |  Branch (648:8): [True: 0, False: 0]
  ------------------
  649|      0|				p->break_loop = 0;
  650|      0|				return (-2);
  651|      0|			} else
  652|      0|				return (n);
  653|      0|		}
  654|       |
  655|  51.0k|		status = p->next_packet_op(p, &h, &data);
  656|  51.0k|		if (status < 0) {
  ------------------
  |  Branch (656:7): [True: 677, False: 50.4k]
  ------------------
  657|       |			/*
  658|       |			 * Error.  Pass it back to the caller.
  659|       |			 */
  660|    677|			return (status);
  661|    677|		}
  662|  50.4k|		if (status == 0) {
  ------------------
  |  Branch (662:7): [True: 1.22k, False: 49.1k]
  ------------------
  663|       |			/*
  664|       |			 * EOF.  Nothing more to process;
  665|       |			 */
  666|  1.22k|			break;
  667|  1.22k|		}
  668|       |
  669|       |		/*
  670|       |		 * OK, we've read a packet; run it through the filter
  671|       |		 * and, if it passes, process it.
  672|       |		 */
  673|  49.1k|		if ((fcode = p->fcode.bf_insns) == NULL ||
  ------------------
  |  Branch (673:7): [True: 49.1k, False: 0]
  ------------------
  674|  49.1k|		    pcapint_filter(fcode, data, h.len, h.caplen)) {
  ------------------
  |  Branch (674:7): [True: 0, False: 0]
  ------------------
  675|  49.1k|			(*callback)(user, &h, data);
  676|  49.1k|			n++;	/* count the packet */
  677|  49.1k|			if (n >= cnt)
  ------------------
  |  Branch (677:8): [True: 49.1k, False: 0]
  ------------------
  678|  49.1k|				break;
  679|  49.1k|		}
  680|  49.1k|	}
  681|       |	/*XXX this breaks semantics tcpslice expects */
  682|  50.4k|	return (n);
  683|  51.0k|}
savefile.c:sf_stats:
  118|  1.89k|{
  119|  1.89k|	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|  1.89k|#define PCAP_ERRBUF_SIZE 256
  ------------------
  120|  1.89k|	    "Statistics aren't available from savefiles");
  121|  1.89k|	return (-1);
  122|  1.89k|}

pcap_check_header:
  220|  2.72k|{
  221|  2.72k|	bpf_u_int32 magic_int;
  222|  2.72k|	struct pcap_file_header hdr;
  223|  2.72k|	size_t amt_read;
  224|  2.72k|	pcap_t *p;
  225|  2.72k|	int swapped = 0;
  226|  2.72k|	struct pcap_sf *ps;
  227|       |
  228|       |	/*
  229|       |	 * Assume no read errors.
  230|       |	 */
  231|  2.72k|	*err = 0;
  232|       |
  233|       |	/*
  234|       |	 * Check whether the first 4 bytes of the file are the magic
  235|       |	 * number for a pcap savefile, or for a byte-swapped pcap
  236|       |	 * savefile.
  237|       |	 */
  238|  2.72k|	memcpy(&magic_int, magic, sizeof(magic_int));
  239|  2.72k|	if (magic_int != TCPDUMP_MAGIC &&
  ------------------
  |  |   71|  5.44k|#define TCPDUMP_MAGIC		0xa1b2c3d4
  ------------------
  |  Branch (239:6): [True: 1.68k, False: 1.03k]
  ------------------
  240|  2.72k|	    magic_int != KUZNETZOV_TCPDUMP_MAGIC &&
  ------------------
  |  |   76|  4.41k|#define KUZNETZOV_TCPDUMP_MAGIC	0xa1b2cd34
  ------------------
  |  Branch (240:6): [True: 1.68k, False: 1]
  ------------------
  241|  2.72k|	    magic_int != NSEC_TCPDUMP_MAGIC) {
  ------------------
  |  |   94|  1.68k|#define NSEC_TCPDUMP_MAGIC	0xa1b23c4d
  ------------------
  |  Branch (241:6): [True: 1.66k, False: 20]
  ------------------
  242|  1.66k|		magic_int = SWAPLONG(magic_int);
  ------------------
  |  |   54|  1.66k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  1.66k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  1.66k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  1.66k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  243|  1.66k|		if (magic_int != TCPDUMP_MAGIC &&
  ------------------
  |  |   71|  3.33k|#define TCPDUMP_MAGIC		0xa1b2c3d4
  ------------------
  |  Branch (243:7): [True: 1.20k, False: 465]
  ------------------
  244|  1.66k|		    magic_int != KUZNETZOV_TCPDUMP_MAGIC &&
  ------------------
  |  |   76|  2.86k|#define KUZNETZOV_TCPDUMP_MAGIC	0xa1b2cd34
  ------------------
  |  Branch (244:7): [True: 1.19k, False: 3]
  ------------------
  245|  1.66k|		    magic_int != NSEC_TCPDUMP_MAGIC)
  ------------------
  |  |   94|  1.19k|#define NSEC_TCPDUMP_MAGIC	0xa1b23c4d
  ------------------
  |  Branch (245:7): [True: 1.03k, False: 165]
  ------------------
  246|  1.03k|			return (NULL);	/* nope */
  247|    633|		swapped = 1;
  248|    633|	}
  249|       |
  250|       |	/*
  251|       |	 * They are.  Put the magic number in the header, and read
  252|       |	 * the rest of the header.
  253|       |	 */
  254|  1.69k|	hdr.magic = magic_int;
  255|  1.69k|	amt_read = fread(((char *)&hdr) + sizeof hdr.magic, 1,
  256|  1.69k|	    sizeof(hdr) - sizeof(hdr.magic), fp);
  257|  1.69k|	if (amt_read != sizeof(hdr) - sizeof(hdr.magic)) {
  ------------------
  |  Branch (257:6): [True: 4, False: 1.68k]
  ------------------
  258|      4|		if (ferror(fp)) {
  ------------------
  |  Branch (258:7): [True: 0, False: 4]
  ------------------
  259|      0|			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  260|      0|			    errno, "error reading dump file");
  261|      4|		} else {
  262|      4|			snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      4|#define PCAP_ERRBUF_SIZE 256
  ------------------
  263|      4|			    "truncated dump file; tried to read %zu file header bytes, only got %zu",
  264|      4|			    sizeof(hdr), amt_read);
  265|      4|		}
  266|      4|		*err = 1;
  267|      4|		return (NULL);
  268|      4|	}
  269|       |
  270|       |	/*
  271|       |	 * If it's a byte-swapped capture file, byte-swap the header.
  272|       |	 */
  273|  1.68k|	if (swapped) {
  ------------------
  |  Branch (273:6): [True: 631, False: 1.05k]
  ------------------
  274|    631|		hdr.version_major = SWAPSHORT(hdr.version_major);
  ------------------
  |  |   59|    631|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|    631|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  275|    631|		hdr.version_minor = SWAPSHORT(hdr.version_minor);
  ------------------
  |  |   59|    631|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|    631|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  276|    631|		hdr.thiszone = SWAPLONG(hdr.thiszone);
  ------------------
  |  |   54|    631|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    631|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    631|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    631|     ((((u_int)(y))>>24)&0xff))
  ------------------
  277|    631|		hdr.sigfigs = SWAPLONG(hdr.sigfigs);
  ------------------
  |  |   54|    631|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    631|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    631|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    631|     ((((u_int)(y))>>24)&0xff))
  ------------------
  278|    631|		hdr.snaplen = SWAPLONG(hdr.snaplen);
  ------------------
  |  |   54|    631|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    631|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    631|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    631|     ((((u_int)(y))>>24)&0xff))
  ------------------
  279|    631|		hdr.linktype = SWAPLONG(hdr.linktype);
  ------------------
  |  |   54|    631|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|    631|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|    631|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|    631|     ((((u_int)(y))>>24)&0xff))
  ------------------
  280|    631|	}
  281|       |
  282|  1.68k|	if (hdr.version_major < PCAP_VERSION_MAJOR) {
  ------------------
  |  |  146|  1.68k|#define PCAP_VERSION_MAJOR 2
  ------------------
  |  Branch (282:6): [True: 1, False: 1.68k]
  ------------------
  283|      1|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
  284|      1|		    "archaic pcap savefile format");
  285|      1|		*err = 1;
  286|      1|		return (NULL);
  287|      1|	}
  288|       |
  289|       |	/*
  290|       |	 * currently only versions 2.[0-4] are supported with
  291|       |	 * the exception of 543.0 for DG/UX tcpdump.
  292|       |	 */
  293|  1.68k|	if (! ((hdr.version_major == PCAP_VERSION_MAJOR &&
  ------------------
  |  |  146|  3.37k|#define PCAP_VERSION_MAJOR 2
  ------------------
  |  Branch (293:10): [True: 1.68k, False: 4]
  ------------------
  294|  1.68k|		hdr.version_minor <= PCAP_VERSION_MINOR) ||
  ------------------
  |  |  147|  1.68k|#define PCAP_VERSION_MINOR 4
  ------------------
  |  Branch (294:3): [True: 1.68k, False: 1]
  ------------------
  295|  1.68k|	       (hdr.version_major == 543 &&
  ------------------
  |  Branch (295:10): [True: 3, False: 2]
  ------------------
  296|      5|		hdr.version_minor == 0))) {
  ------------------
  |  Branch (296:3): [True: 2, False: 1]
  ------------------
  297|      3|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      3|#define PCAP_ERRBUF_SIZE 256
  ------------------
  298|      3|			 "unsupported pcap savefile version %u.%u",
  299|      3|			 hdr.version_major, hdr.version_minor);
  300|      3|		*err = 1;
  301|      3|		return NULL;
  302|      3|	}
  303|       |
  304|       |	/*
  305|       |	 * Check the main reserved field.
  306|       |	 */
  307|  1.68k|	if (LT_RESERVED1(hdr.linktype) != 0) {
  ------------------
  |  |  267|  1.68k|#define LT_RESERVED1(x)			((x) & 0x03FF0000)
  ------------------
  |  Branch (307:6): [True: 2, False: 1.68k]
  ------------------
  308|      2|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      2|#define PCAP_ERRBUF_SIZE 256
  ------------------
  309|      2|			 "savefile linktype reserved field not zero (0x%08x)",
  310|      2|			 LT_RESERVED1(hdr.linktype));
  ------------------
  |  |  267|      2|#define LT_RESERVED1(x)			((x) & 0x03FF0000)
  ------------------
  311|      2|		*err = 1;
  312|      2|		return NULL;
  313|      2|	}
  314|       |
  315|       |	/*
  316|       |	 * OK, this is a good pcap file.
  317|       |	 * Allocate a pcap_t for it.
  318|       |	 */
  319|  1.68k|	p = PCAP_OPEN_OFFLINE_COMMON(errbuf, struct pcap_sf);
  ------------------
  |  |  514|  1.68k|	pcapint_open_offline_common(ebuf, \
  |  |  515|  1.68k|	    sizeof (struct { pcap_t __common; type __private; }), \
  |  |  516|  1.68k|	    offsetof (struct { pcap_t __common; type __private; }, __private))
  ------------------
  320|  1.68k|	if (p == NULL) {
  ------------------
  |  Branch (320:6): [True: 0, False: 1.68k]
  ------------------
  321|       |		/* Allocation failed. */
  322|      0|		*err = 1;
  323|      0|		return (NULL);
  324|      0|	}
  325|  1.68k|	p->swapped = swapped;
  326|  1.68k|	p->version_major = hdr.version_major;
  327|  1.68k|	p->version_minor = hdr.version_minor;
  328|  1.68k|	p->linktype = linktype_to_dlt(LT_LINKTYPE(hdr.linktype));
  ------------------
  |  |  265|  1.68k|#define LT_LINKTYPE(x)			((x) & 0x0000FFFF)
  ------------------
  329|  1.68k|	p->linktype_ext = LT_LINKTYPE_EXT(hdr.linktype);
  ------------------
  |  |  266|  1.68k|#define LT_LINKTYPE_EXT(x)		((x) & 0xFFFF0000)
  ------------------
  330|  1.68k|	p->snapshot = pcapint_adjust_snapshot(p->linktype, hdr.snaplen);
  331|       |
  332|  1.68k|	p->next_packet_op = pcap_next_packet;
  333|       |
  334|  1.68k|	ps = p->priv;
  335|       |
  336|  1.68k|	p->opt.tstamp_precision = precision;
  337|       |
  338|       |	/*
  339|       |	 * Will we need to scale the timestamps to match what the
  340|       |	 * user wants?
  341|       |	 */
  342|  1.68k|	switch (precision) {
  343|       |
  344|  1.68k|	case PCAP_TSTAMP_PRECISION_MICRO:
  ------------------
  |  |  537|  1.68k|#define PCAP_TSTAMP_PRECISION_MICRO	0	/* use timestamps with microsecond precision, default */
  ------------------
  |  Branch (344:2): [True: 1.68k, False: 0]
  ------------------
  345|  1.68k|		if (magic_int == NSEC_TCPDUMP_MAGIC) {
  ------------------
  |  |   94|  1.68k|#define NSEC_TCPDUMP_MAGIC	0xa1b23c4d
  ------------------
  |  Branch (345:7): [True: 183, False: 1.49k]
  ------------------
  346|       |			/*
  347|       |			 * The file has nanoseconds, the user
  348|       |			 * wants microseconds; scale the
  349|       |			 * precision down.
  350|       |			 */
  351|    183|			ps->scale_type = SCALE_DOWN;
  352|  1.49k|		} else {
  353|       |			/*
  354|       |			 * The file has microseconds, the
  355|       |			 * user wants microseconds; nothing to do.
  356|       |			 */
  357|  1.49k|			ps->scale_type = PASS_THROUGH;
  358|  1.49k|		}
  359|  1.68k|		break;
  360|       |
  361|      0|	case PCAP_TSTAMP_PRECISION_NANO:
  ------------------
  |  |  538|      0|#define PCAP_TSTAMP_PRECISION_NANO	1	/* use timestamps with nanosecond precision */
  ------------------
  |  Branch (361:2): [True: 0, False: 1.68k]
  ------------------
  362|      0|		if (magic_int == NSEC_TCPDUMP_MAGIC) {
  ------------------
  |  |   94|      0|#define NSEC_TCPDUMP_MAGIC	0xa1b23c4d
  ------------------
  |  Branch (362:7): [True: 0, False: 0]
  ------------------
  363|       |			/*
  364|       |			 * The file has nanoseconds, the
  365|       |			 * user wants nanoseconds; nothing to do.
  366|       |			 */
  367|      0|			ps->scale_type = PASS_THROUGH;
  368|      0|		} else {
  369|       |			/*
  370|       |			 * The file has microseconds, the user
  371|       |			 * wants nanoseconds; scale the
  372|       |			 * precision up.
  373|       |			 */
  374|      0|			ps->scale_type = SCALE_UP;
  375|      0|		}
  376|      0|		break;
  377|       |
  378|      0|	default:
  ------------------
  |  Branch (378:2): [True: 0, False: 1.68k]
  ------------------
  379|      0|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  380|      0|		    "unknown time stamp resolution %u", precision);
  381|      0|		free(p);
  382|      0|		*err = 1;
  383|      0|		return (NULL);
  384|  1.68k|	}
  385|       |
  386|       |	/*
  387|       |	 * We interchanged the caplen and len fields at version 2.3,
  388|       |	 * in order to match the bpf header layout.  But unfortunately
  389|       |	 * some files were written with version 2.3 in their headers
  390|       |	 * but without the interchanged fields.
  391|       |	 *
  392|       |	 * In addition, DG/UX tcpdump writes out files with a version
  393|       |	 * number of 543.0, and with the caplen and len fields in the
  394|       |	 * pre-2.3 order.
  395|       |	 */
  396|  1.68k|	switch (hdr.version_major) {
  397|       |
  398|  1.67k|	case 2:
  ------------------
  |  Branch (398:2): [True: 1.67k, False: 1]
  ------------------
  399|  1.67k|		if (hdr.version_minor < 3)
  ------------------
  |  Branch (399:7): [True: 38, False: 1.64k]
  ------------------
  400|     38|			ps->lengths_swapped = SWAPPED;
  401|  1.64k|		else if (hdr.version_minor == 3)
  ------------------
  |  Branch (401:12): [True: 51, False: 1.59k]
  ------------------
  402|     51|			ps->lengths_swapped = MAYBE_SWAPPED;
  403|  1.59k|		else
  404|  1.59k|			ps->lengths_swapped = NOT_SWAPPED;
  405|  1.67k|		break;
  406|       |
  407|      1|	case 543:
  ------------------
  |  Branch (407:2): [True: 1, False: 1.67k]
  ------------------
  408|      1|		ps->lengths_swapped = SWAPPED;
  409|      1|		break;
  410|       |
  411|      0|	default:
  ------------------
  |  Branch (411:2): [True: 0, False: 1.68k]
  ------------------
  412|      0|		ps->lengths_swapped = NOT_SWAPPED;
  413|      0|		break;
  414|  1.68k|	}
  415|       |
  416|  1.68k|	if (magic_int == KUZNETZOV_TCPDUMP_MAGIC) {
  ------------------
  |  |   76|  1.68k|#define KUZNETZOV_TCPDUMP_MAGIC	0xa1b2cd34
  ------------------
  |  Branch (416:6): [True: 2, False: 1.67k]
  ------------------
  417|       |		/*
  418|       |		 * XXX - the patch that's in some versions of libpcap
  419|       |		 * changes the packet header but not the magic number,
  420|       |		 * and some other versions with this magic number have
  421|       |		 * some extra debugging information in the packet header;
  422|       |		 * we'd have to use some hacks^H^H^H^H^Hheuristics to
  423|       |		 * detect those variants.
  424|       |		 *
  425|       |		 * Ethereal does that, but it does so by trying to read
  426|       |		 * the first two packets of the file with each of the
  427|       |		 * record header formats.  That currently means it seeks
  428|       |		 * backwards and retries the reads, which doesn't work
  429|       |		 * on pipes.  We want to be able to read from a pipe, so
  430|       |		 * that strategy won't work; we'd have to buffer some
  431|       |		 * data ourselves and read from that buffer in order to
  432|       |		 * make that work.
  433|       |		 */
  434|      2|		ps->hdrsize = sizeof(struct pcap_sf_patched_pkthdr);
  435|       |
  436|      2|		if (p->linktype == DLT_EN10MB) {
  ------------------
  |  |   68|      2|#define DLT_EN10MB	1	/* Ethernet (10Mb) */
  ------------------
  |  Branch (436:7): [True: 1, False: 1]
  ------------------
  437|       |			/*
  438|       |			 * This capture might have been done in raw mode
  439|       |			 * or cooked mode.
  440|       |			 *
  441|       |			 * If it was done in cooked mode, p->snapshot was
  442|       |			 * passed to recvfrom() as the buffer size, meaning
  443|       |			 * that the most packet data that would be copied
  444|       |			 * would be p->snapshot.  However, a faked Ethernet
  445|       |			 * header would then have been added to it, so the
  446|       |			 * most data that would be in a packet in the file
  447|       |			 * would be p->snapshot + 14.
  448|       |			 *
  449|       |			 * We can't easily tell whether the capture was done
  450|       |			 * in raw mode or cooked mode, so we'll assume it was
  451|       |			 * cooked mode, and add 14 to the snapshot length.
  452|       |			 * That means that, for a raw capture, the snapshot
  453|       |			 * length will be misleading if you use it to figure
  454|       |			 * out why a capture doesn't have all the packet data,
  455|       |			 * but there's not much we can do to avoid that.
  456|       |			 *
  457|       |			 * But don't grow the snapshot length past the
  458|       |			 * maximum value of an int.
  459|       |			 */
  460|      1|			if (p->snapshot <= INT_MAX - 14)
  ------------------
  |  Branch (460:8): [True: 1, False: 0]
  ------------------
  461|      1|				p->snapshot += 14;
  462|      0|			else
  463|      0|				p->snapshot = INT_MAX;
  464|      1|		}
  465|      2|	} else
  466|  1.67k|		ps->hdrsize = sizeof(struct pcap_sf_pkthdr);
  467|       |
  468|       |	/*
  469|       |	 * Allocate a buffer for the packet data.
  470|       |	 * Choose the minimum of the file's snapshot length and 2K bytes;
  471|       |	 * that should be enough for most network packets - we'll grow it
  472|       |	 * if necessary.  That way, we don't allocate a huge chunk of
  473|       |	 * memory just because there's a huge snapshot length, as the
  474|       |	 * snapshot length might be larger than the size of the largest
  475|       |	 * packet.
  476|       |	 */
  477|  1.68k|	p->bufsize = p->snapshot;
  478|  1.68k|	if (p->bufsize > 2048)
  ------------------
  |  Branch (478:6): [True: 1.24k, False: 437]
  ------------------
  479|  1.24k|		p->bufsize = 2048;
  480|  1.68k|	p->buffer = malloc(p->bufsize);
  481|  1.68k|	if (p->buffer == NULL) {
  ------------------
  |  Branch (481:6): [True: 0, False: 1.68k]
  ------------------
  482|      0|		snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  483|      0|		free(p);
  484|      0|		*err = 1;
  485|      0|		return (NULL);
  486|      0|	}
  487|       |
  488|  1.68k|	p->cleanup_op = pcapint_sf_cleanup;
  489|       |
  490|  1.68k|	return (p);
  491|  1.68k|}
sf-pcap.c:pcap_next_packet:
  518|  49.3k|{
  519|  49.3k|	struct pcap_sf *ps = p->priv;
  520|  49.3k|	struct pcap_sf_patched_pkthdr sf_hdr;
  521|  49.3k|	FILE *fp = p->rfile;
  522|  49.3k|	size_t amt_read;
  523|  49.3k|	bpf_u_int32 t;
  524|       |
  525|       |	/*
  526|       |	 * Read the packet header; the structure we use as a buffer
  527|       |	 * is the longer structure for files generated by the patched
  528|       |	 * libpcap, but if the file has the magic number for an
  529|       |	 * unpatched libpcap we only read as many bytes as the regular
  530|       |	 * header has.
  531|       |	 */
  532|  49.3k|	amt_read = fread(&sf_hdr, 1, ps->hdrsize, fp);
  533|  49.3k|	if (amt_read != ps->hdrsize) {
  ------------------
  |  Branch (533:6): [True: 1.34k, False: 48.0k]
  ------------------
  534|  1.34k|		if (ferror(fp)) {
  ------------------
  |  Branch (534:7): [True: 0, False: 1.34k]
  ------------------
  535|      0|			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  536|      0|			    errno, "error reading dump file");
  537|      0|			return (-1);
  538|  1.34k|		} else {
  539|  1.34k|			if (amt_read != 0) {
  ------------------
  |  Branch (539:8): [True: 196, False: 1.15k]
  ------------------
  540|    196|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|    196|#define PCAP_ERRBUF_SIZE 256
  ------------------
  541|    196|				    "truncated dump file; tried to read %zu header bytes, only got %zu",
  542|    196|				    ps->hdrsize, amt_read);
  543|    196|				return (-1);
  544|    196|			}
  545|       |			/* EOF */
  546|  1.15k|			return (0);
  547|  1.34k|		}
  548|  1.34k|	}
  549|       |
  550|  48.0k|	if (p->swapped) {
  ------------------
  |  Branch (550:6): [True: 33.5k, False: 14.4k]
  ------------------
  551|       |		/* these were written in opposite byte order */
  552|  33.5k|		hdr->caplen = SWAPLONG(sf_hdr.caplen);
  ------------------
  |  |   54|  33.5k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  33.5k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  33.5k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  33.5k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  553|  33.5k|		hdr->len = SWAPLONG(sf_hdr.len);
  ------------------
  |  |   54|  33.5k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  33.5k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  33.5k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  33.5k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  554|  33.5k|		hdr->ts.tv_sec = SWAPLONG(sf_hdr.ts.tv_sec);
  ------------------
  |  |   54|  33.5k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  33.5k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  33.5k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  33.5k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  555|  33.5k|		hdr->ts.tv_usec = SWAPLONG(sf_hdr.ts.tv_usec);
  ------------------
  |  |   54|  33.5k|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|  33.5k|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|  33.5k|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|  33.5k|     ((((u_int)(y))>>24)&0xff))
  ------------------
  556|  33.5k|	} else {
  557|  14.4k|		hdr->caplen = sf_hdr.caplen;
  558|  14.4k|		hdr->len = sf_hdr.len;
  559|  14.4k|		hdr->ts.tv_sec = sf_hdr.ts.tv_sec;
  560|  14.4k|		hdr->ts.tv_usec = sf_hdr.ts.tv_usec;
  561|  14.4k|	}
  562|       |
  563|  48.0k|	switch (ps->scale_type) {
  ------------------
  |  Branch (563:10): [True: 0, False: 48.0k]
  ------------------
  564|       |
  565|  30.0k|	case PASS_THROUGH:
  ------------------
  |  Branch (565:2): [True: 30.0k, False: 18.0k]
  ------------------
  566|       |		/*
  567|       |		 * Just pass the time stamp through.
  568|       |		 */
  569|  30.0k|		break;
  570|       |
  571|      0|	case SCALE_UP:
  ------------------
  |  Branch (571:2): [True: 0, False: 48.0k]
  ------------------
  572|       |		/*
  573|       |		 * File has microseconds, user wants nanoseconds; convert
  574|       |		 * it.
  575|       |		 */
  576|      0|		hdr->ts.tv_usec = hdr->ts.tv_usec * 1000;
  577|      0|		break;
  578|       |
  579|  18.0k|	case SCALE_DOWN:
  ------------------
  |  Branch (579:2): [True: 18.0k, False: 30.0k]
  ------------------
  580|       |		/*
  581|       |		 * File has nanoseconds, user wants microseconds; convert
  582|       |		 * it.
  583|       |		 */
  584|  18.0k|		hdr->ts.tv_usec = hdr->ts.tv_usec / 1000;
  585|  18.0k|		break;
  586|  48.0k|	}
  587|       |
  588|       |	/* Swap the caplen and len fields, if necessary. */
  589|  48.0k|	switch (ps->lengths_swapped) {
  ------------------
  |  Branch (589:10): [True: 0, False: 48.0k]
  ------------------
  590|       |
  591|  44.8k|	case NOT_SWAPPED:
  ------------------
  |  Branch (591:2): [True: 44.8k, False: 3.16k]
  ------------------
  592|  44.8k|		break;
  593|       |
  594|  1.05k|	case MAYBE_SWAPPED:
  ------------------
  |  Branch (594:2): [True: 1.05k, False: 46.9k]
  ------------------
  595|  1.05k|		if (hdr->caplen <= hdr->len) {
  ------------------
  |  Branch (595:7): [True: 841, False: 210]
  ------------------
  596|       |			/*
  597|       |			 * The captured length is <= the actual length,
  598|       |			 * so presumably they weren't swapped.
  599|       |			 */
  600|    841|			break;
  601|    841|		}
  602|       |		/* FALLTHROUGH */
  603|       |
  604|  2.32k|	case SWAPPED:
  ------------------
  |  Branch (604:2): [True: 2.11k, False: 45.9k]
  ------------------
  605|  2.32k|		t = hdr->caplen;
  606|  2.32k|		hdr->caplen = hdr->len;
  607|  2.32k|		hdr->len = t;
  608|  2.32k|		break;
  609|  48.0k|	}
  610|       |
  611|       |	/*
  612|       |	 * Is the packet bigger than we consider sane?
  613|       |	 */
  614|  48.0k|	if (hdr->caplen > max_snaplen_for_dlt(p->linktype)) {
  ------------------
  |  Branch (614:6): [True: 177, False: 47.8k]
  ------------------
  615|       |		/*
  616|       |		 * Yes.  This may be a damaged or fuzzed file.
  617|       |		 *
  618|       |		 * Is it bigger than the snapshot length?
  619|       |		 * (We don't treat that as an error if it's not
  620|       |		 * bigger than the maximum we consider sane; see
  621|       |		 * below.)
  622|       |		 */
  623|    177|		if (hdr->caplen > (bpf_u_int32)p->snapshot) {
  ------------------
  |  Branch (623:7): [True: 165, False: 12]
  ------------------
  624|    165|			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|    165|#define PCAP_ERRBUF_SIZE 256
  ------------------
  625|    165|			    "invalid packet capture length %u, bigger than "
  626|    165|			    "snaplen of %d", hdr->caplen, p->snapshot);
  627|    165|		} else {
  628|     12|			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|     12|#define PCAP_ERRBUF_SIZE 256
  ------------------
  629|     12|			    "invalid packet capture length %u, bigger than "
  630|     12|			    "maximum of %u", hdr->caplen,
  631|     12|			    max_snaplen_for_dlt(p->linktype));
  632|     12|		}
  633|    177|		return (-1);
  634|    177|	}
  635|       |
  636|  47.8k|	if (hdr->caplen > (bpf_u_int32)p->snapshot) {
  ------------------
  |  Branch (636:6): [True: 8.87k, False: 39.0k]
  ------------------
  637|       |		/*
  638|       |		 * The packet is bigger than the snapshot length
  639|       |		 * for this file.
  640|       |		 *
  641|       |		 * This can happen due to Solaris 2.3 systems tripping
  642|       |		 * over the BUFMOD problem and not setting the snapshot
  643|       |		 * length correctly in the savefile header.
  644|       |		 *
  645|       |		 * libpcap 0.4 and later on Solaris 2.3 should set the
  646|       |		 * snapshot length correctly in the pcap file header,
  647|       |		 * even though they don't set a snapshot length in bufmod
  648|       |		 * (the buggy bufmod chops off the *beginning* of the
  649|       |		 * packet if a snapshot length is specified); they should
  650|       |		 * also reduce the captured length, as supplied to the
  651|       |		 * per-packet callback, to the snapshot length if it's
  652|       |		 * greater than the snapshot length, so the code using
  653|       |		 * libpcap should see the packet cut off at the snapshot
  654|       |		 * length, even though the full packet is copied up to
  655|       |		 * userland.
  656|       |		 *
  657|       |		 * However, perhaps some versions of libpcap failed to
  658|       |		 * set the snapshot length correctly in the file header
  659|       |		 * or the per-packet header, or perhaps this is a
  660|       |		 * corrupted savefile or a savefile built/modified by a
  661|       |		 * fuzz tester, so we check anyway.  We grow the buffer
  662|       |		 * to be big enough for the snapshot length, read up
  663|       |		 * to the snapshot length, discard the rest of the
  664|       |		 * packet, and report the snapshot length as the captured
  665|       |		 * length; we don't want to hand our caller a packet
  666|       |		 * bigger than the snapshot length, because they might
  667|       |		 * be assuming they'll never be handed such a packet,
  668|       |		 * and might copy the packet into a snapshot-length-
  669|       |		 * sized buffer, assuming it'll fit.
  670|       |		 */
  671|  8.87k|		size_t bytes_to_discard;
  672|  8.87k|		size_t bytes_to_read, bytes_read;
  673|  8.87k|		char discard_buf[4096];
  674|       |
  675|  8.87k|		if (hdr->caplen > p->bufsize) {
  ------------------
  |  Branch (675:7): [True: 8.87k, False: 0]
  ------------------
  676|       |			/*
  677|       |			 * Grow the buffer to the snapshot length.
  678|       |			 */
  679|  8.87k|			if (!grow_buffer(p, p->snapshot))
  ------------------
  |  Branch (679:8): [True: 0, False: 8.87k]
  ------------------
  680|      0|				return (-1);
  681|  8.87k|		}
  682|       |
  683|       |		/*
  684|       |		 * Read the first p->snapshot bytes into the buffer.
  685|       |		 */
  686|  8.87k|		amt_read = fread(p->buffer, 1, p->snapshot, fp);
  687|  8.87k|		if (amt_read != (bpf_u_int32)p->snapshot) {
  ------------------
  |  Branch (687:7): [True: 26, False: 8.84k]
  ------------------
  688|     26|			if (ferror(fp)) {
  ------------------
  |  Branch (688:8): [True: 0, False: 26]
  ------------------
  689|      0|				pcapint_fmt_errmsg_for_errno(p->errbuf,
  690|      0|				     PCAP_ERRBUF_SIZE, errno,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  691|      0|				    "error reading dump file");
  692|     26|			} else {
  693|       |				/*
  694|       |				 * Yes, this uses hdr->caplen; technically,
  695|       |				 * it's true, because we would try to read
  696|       |				 * and discard the rest of those bytes, and
  697|       |				 * that would fail because we got EOF before
  698|       |				 * the read finished.
  699|       |				 */
  700|     26|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|     26|#define PCAP_ERRBUF_SIZE 256
  ------------------
  701|     26|				    "truncated dump file; tried to read %d captured bytes, only got %zu",
  702|     26|				    p->snapshot, amt_read);
  703|     26|			}
  704|     26|			return (-1);
  705|     26|		}
  706|       |
  707|       |		/*
  708|       |		 * Now read and discard what's left.
  709|       |		 */
  710|  8.84k|		bytes_to_discard = hdr->caplen - p->snapshot;
  711|  8.84k|		bytes_read = amt_read;
  712|  17.7k|		while (bytes_to_discard != 0) {
  ------------------
  |  Branch (712:10): [True: 8.88k, False: 8.83k]
  ------------------
  713|  8.88k|			bytes_to_read = bytes_to_discard;
  714|  8.88k|			if (bytes_to_read > sizeof (discard_buf))
  ------------------
  |  Branch (714:8): [True: 50, False: 8.83k]
  ------------------
  715|     50|				bytes_to_read = sizeof (discard_buf);
  716|  8.88k|			amt_read = fread(discard_buf, 1, bytes_to_read, fp);
  717|  8.88k|			bytes_read += amt_read;
  718|  8.88k|			if (amt_read != bytes_to_read) {
  ------------------
  |  Branch (718:8): [True: 14, False: 8.86k]
  ------------------
  719|     14|				if (ferror(fp)) {
  ------------------
  |  Branch (719:9): [True: 0, False: 14]
  ------------------
  720|      0|					pcapint_fmt_errmsg_for_errno(p->errbuf,
  721|      0|					    PCAP_ERRBUF_SIZE, errno,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  722|      0|					    "error reading dump file");
  723|     14|				} else {
  724|     14|					snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|     14|#define PCAP_ERRBUF_SIZE 256
  ------------------
  725|     14|					    "truncated dump file; tried to read %u captured bytes, only got %zu",
  726|     14|					    hdr->caplen, bytes_read);
  727|     14|				}
  728|     14|				return (-1);
  729|     14|			}
  730|  8.86k|			bytes_to_discard -= amt_read;
  731|  8.86k|		}
  732|       |
  733|       |		/*
  734|       |		 * Adjust caplen accordingly, so we don't get confused later
  735|       |		 * as to how many bytes we have to play with.
  736|       |		 */
  737|  8.83k|		hdr->caplen = p->snapshot;
  738|  39.0k|	} else {
  739|       |		/*
  740|       |		 * The packet is within the snapshot length for this file.
  741|       |		 */
  742|  39.0k|		if (hdr->caplen > p->bufsize) {
  ------------------
  |  Branch (742:7): [True: 159, False: 38.8k]
  ------------------
  743|       |			/*
  744|       |			 * Grow the buffer to the next power of 2, or
  745|       |			 * the snaplen, whichever is lower.
  746|       |			 */
  747|    159|			u_int new_bufsize;
  748|       |
  749|    159|			new_bufsize = hdr->caplen;
  750|       |			/*
  751|       |			 * https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
  752|       |			 */
  753|    159|			new_bufsize--;
  754|    159|			new_bufsize |= new_bufsize >> 1;
  755|    159|			new_bufsize |= new_bufsize >> 2;
  756|    159|			new_bufsize |= new_bufsize >> 4;
  757|    159|			new_bufsize |= new_bufsize >> 8;
  758|    159|			new_bufsize |= new_bufsize >> 16;
  759|    159|			new_bufsize++;
  760|       |
  761|    159|			if (new_bufsize > (u_int)p->snapshot)
  ------------------
  |  Branch (761:8): [True: 66, False: 93]
  ------------------
  762|     66|				new_bufsize = p->snapshot;
  763|       |
  764|    159|			if (!grow_buffer(p, new_bufsize))
  ------------------
  |  Branch (764:8): [True: 0, False: 159]
  ------------------
  765|      0|				return (-1);
  766|    159|		}
  767|       |
  768|       |		/* read the packet itself */
  769|  39.0k|		amt_read = fread(p->buffer, 1, hdr->caplen, fp);
  770|  39.0k|		if (amt_read != hdr->caplen) {
  ------------------
  |  Branch (770:7): [True: 115, False: 38.8k]
  ------------------
  771|    115|			if (ferror(fp)) {
  ------------------
  |  Branch (771:8): [True: 0, False: 115]
  ------------------
  772|      0|				pcapint_fmt_errmsg_for_errno(p->errbuf,
  773|      0|				    PCAP_ERRBUF_SIZE, errno,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  774|      0|				    "error reading dump file");
  775|    115|			} else {
  776|    115|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|    115|#define PCAP_ERRBUF_SIZE 256
  ------------------
  777|    115|				    "truncated dump file; tried to read %u captured bytes, only got %zu",
  778|    115|				    hdr->caplen, amt_read);
  779|    115|			}
  780|    115|			return (-1);
  781|    115|		}
  782|  39.0k|	}
  783|  47.7k|	*data = p->buffer;
  784|       |
  785|  47.7k|	pcapint_post_process(p->linktype, p->swapped, hdr, *data);
  786|       |
  787|  47.7k|	return (1);
  788|  47.8k|}
sf-pcap.c:grow_buffer:
  498|  9.02k|{
  499|  9.02k|	void *bigger_buffer;
  500|       |
  501|  9.02k|	bigger_buffer = realloc(p->buffer, bufsize);
  502|  9.02k|	if (bigger_buffer == NULL) {
  ------------------
  |  Branch (502:6): [True: 0, False: 9.02k]
  ------------------
  503|      0|		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "out of memory");
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  504|      0|		return (0);
  505|      0|	}
  506|  9.02k|	p->buffer = bigger_buffer;
  507|  9.02k|	p->bufsize = bufsize;
  508|  9.02k|	return (1);
  509|  9.02k|}

pcap_ng_check_header:
  770|  1.03k|{
  771|  1.03k|	bpf_u_int32 magic_int;
  772|  1.03k|	size_t amt_read;
  773|  1.03k|	bpf_u_int32 total_length;
  774|  1.03k|	bpf_u_int32 byte_order_magic;
  775|  1.03k|	struct block_header *bhdrp;
  776|  1.03k|	struct section_header_block *shbp;
  777|  1.03k|	pcap_t *p;
  778|  1.03k|	int swapped = 0;
  779|  1.03k|	struct pcap_ng_sf *ps;
  780|  1.03k|	int status;
  781|  1.03k|	struct block_cursor cursor;
  782|  1.03k|	struct interface_description_block *idbp;
  783|       |
  784|       |	/*
  785|       |	 * Assume no read errors.
  786|       |	 */
  787|  1.03k|	*err = 0;
  788|       |
  789|       |	/*
  790|       |	 * Check whether the first 4 bytes of the file are the block
  791|       |	 * type for a pcapng savefile.
  792|       |	 */
  793|  1.03k|	memcpy(&magic_int, magic, sizeof(magic_int));
  794|  1.03k|	if (magic_int != BT_SHB) {
  ------------------
  |  |   86|  1.03k|#define BT_SHB			0x0A0D0D0A
  ------------------
  |  Branch (794:6): [True: 757, False: 277]
  ------------------
  795|       |		/*
  796|       |		 * XXX - check whether this looks like what the block
  797|       |		 * type would be after being munged by mapping between
  798|       |		 * UN*X and DOS/Windows text file format and, if it
  799|       |		 * does, look for the byte-order magic number in
  800|       |		 * the appropriate place and, if we find it, report
  801|       |		 * this as possibly being a pcapng file transferred
  802|       |		 * between UN*X and Windows in text file format?
  803|       |		 */
  804|    757|		return (NULL);	/* nope */
  805|    757|	}
  806|       |
  807|       |	/*
  808|       |	 * OK, they are.  However, that's just \n\r\r\n, so it could,
  809|       |	 * conceivably, be an ordinary text file.
  810|       |	 *
  811|       |	 * It could not, however, conceivably be any other type of
  812|       |	 * capture file, so we can read the rest of the putative
  813|       |	 * Section Header Block; put the block type in the common
  814|       |	 * header, read the rest of the common header and the
  815|       |	 * fixed-length portion of the SHB, and look for the byte-order
  816|       |	 * magic value.
  817|       |	 */
  818|    277|	amt_read = fread(&total_length, 1, sizeof(total_length), fp);
  819|    277|	if (amt_read < sizeof(total_length)) {
  ------------------
  |  Branch (819:6): [True: 1, False: 276]
  ------------------
  820|      1|		if (ferror(fp)) {
  ------------------
  |  Branch (820:7): [True: 0, False: 1]
  ------------------
  821|      0|			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  822|      0|			    errno, "error reading dump file");
  823|      0|			*err = 1;
  824|      0|			return (NULL);	/* fail */
  825|      0|		}
  826|       |
  827|       |		/*
  828|       |		 * Possibly a weird short text file, so just say
  829|       |		 * "not pcapng".
  830|       |		 */
  831|      1|		return (NULL);
  832|      1|	}
  833|    276|	amt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);
  834|    276|	if (amt_read < sizeof(byte_order_magic)) {
  ------------------
  |  Branch (834:6): [True: 1, False: 275]
  ------------------
  835|      1|		if (ferror(fp)) {
  ------------------
  |  Branch (835:7): [True: 0, False: 1]
  ------------------
  836|      0|			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  837|      0|			    errno, "error reading dump file");
  838|      0|			*err = 1;
  839|      0|			return (NULL);	/* fail */
  840|      0|		}
  841|       |
  842|       |		/*
  843|       |		 * Possibly a weird short text file, so just say
  844|       |		 * "not pcapng".
  845|       |		 */
  846|      1|		return (NULL);
  847|      1|	}
  848|    275|	if (byte_order_magic != BYTE_ORDER_MAGIC) {
  ------------------
  |  |   99|    275|#define BYTE_ORDER_MAGIC	0x1A2B3C4D
  ------------------
  |  Branch (848:6): [True: 14, False: 261]
  ------------------
  849|     14|		byte_order_magic = SWAPLONG(byte_order_magic);
  ------------------
  |  |   54|     14|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|     14|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|     14|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|     14|     ((((u_int)(y))>>24)&0xff))
  ------------------
  850|     14|		if (byte_order_magic != BYTE_ORDER_MAGIC) {
  ------------------
  |  |   99|     14|#define BYTE_ORDER_MAGIC	0x1A2B3C4D
  ------------------
  |  Branch (850:7): [True: 1, False: 13]
  ------------------
  851|       |			/*
  852|       |			 * Not a pcapng file.
  853|       |			 */
  854|      1|			return (NULL);
  855|      1|		}
  856|     13|		swapped = 1;
  857|     13|		total_length = SWAPLONG(total_length);
  ------------------
  |  |   54|     13|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|     13|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|     13|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|     13|     ((((u_int)(y))>>24)&0xff))
  ------------------
  858|     13|	}
  859|       |
  860|       |	/*
  861|       |	 * Check the sanity of the total length.
  862|       |	 */
  863|    274|	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
  ------------------
  |  Branch (863:6): [True: 1, False: 273]
  ------------------
  864|    274|            (total_length > BT_SHB_INSANE_MAX)) {
  ------------------
  |  |   87|    273|#define BT_SHB_INSANE_MAX       1024U*1024U*1U  /* 1MB should be enough */
  ------------------
  |  Branch (864:13): [True: 2, False: 271]
  ------------------
  865|      3|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      3|#define PCAP_ERRBUF_SIZE 256
  ------------------
  866|      3|		    "Section Header Block in pcapng dump file has invalid length %zu < _%u_ < %u (BT_SHB_INSANE_MAX)",
  867|      3|		    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),
  868|      3|		    total_length,
  869|      3|		    BT_SHB_INSANE_MAX);
  ------------------
  |  |   87|      3|#define BT_SHB_INSANE_MAX       1024U*1024U*1U  /* 1MB should be enough */
  ------------------
  870|       |
  871|      3|		*err = 1;
  872|      3|		return (NULL);
  873|      3|	}
  874|       |
  875|       |	/*
  876|       |	 * OK, this is a good pcapng file.
  877|       |	 * Allocate a pcap_t for it.
  878|       |	 */
  879|    271|	p = PCAP_OPEN_OFFLINE_COMMON(errbuf, struct pcap_ng_sf);
  ------------------
  |  |  514|    271|	pcapint_open_offline_common(ebuf, \
  |  |  515|    271|	    sizeof (struct { pcap_t __common; type __private; }), \
  |  |  516|    271|	    offsetof (struct { pcap_t __common; type __private; }, __private))
  ------------------
  880|    271|	if (p == NULL) {
  ------------------
  |  Branch (880:6): [True: 0, False: 271]
  ------------------
  881|       |		/* Allocation failed. */
  882|      0|		*err = 1;
  883|      0|		return (NULL);
  884|      0|	}
  885|    271|	p->swapped = swapped;
  886|    271|	ps = p->priv;
  887|       |
  888|       |	/*
  889|       |	 * What precision does the user want?
  890|       |	 */
  891|    271|	switch (precision) {
  892|       |
  893|    271|	case PCAP_TSTAMP_PRECISION_MICRO:
  ------------------
  |  |  537|    271|#define PCAP_TSTAMP_PRECISION_MICRO	0	/* use timestamps with microsecond precision, default */
  ------------------
  |  Branch (893:2): [True: 271, False: 0]
  ------------------
  894|    271|		ps->user_tsresol = 1000000;
  895|    271|		break;
  896|       |
  897|      0|	case PCAP_TSTAMP_PRECISION_NANO:
  ------------------
  |  |  538|      0|#define PCAP_TSTAMP_PRECISION_NANO	1	/* use timestamps with nanosecond precision */
  ------------------
  |  Branch (897:2): [True: 0, False: 271]
  ------------------
  898|      0|		ps->user_tsresol = 1000000000;
  899|      0|		break;
  900|       |
  901|      0|	default:
  ------------------
  |  Branch (901:2): [True: 0, False: 271]
  ------------------
  902|      0|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  903|      0|		    "unknown time stamp resolution %u", precision);
  904|      0|		free(p);
  905|      0|		*err = 1;
  906|      0|		return (NULL);
  907|    271|	}
  908|       |
  909|    271|	p->opt.tstamp_precision = precision;
  910|       |
  911|       |	/*
  912|       |	 * Allocate a buffer into which to read blocks.  We default to
  913|       |	 * the maximum of:
  914|       |	 *
  915|       |	 *	the total length of the SHB for which we read the header;
  916|       |	 *
  917|       |	 *	2K, which should be more than large enough for an Enhanced
  918|       |	 *	Packet Block containing a full-size Ethernet frame, and
  919|       |	 *	leaving room for some options.
  920|       |	 *
  921|       |	 * If we find a bigger block, we reallocate the buffer, up to
  922|       |	 * the maximum size.  We start out with a maximum size of
  923|       |	 * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types
  924|       |	 * with a maximum snapshot that results in a larger maximum
  925|       |	 * block length, we boost the maximum.
  926|       |	 */
  927|    271|	p->bufsize = 2048;
  928|    271|	if (p->bufsize < total_length)
  ------------------
  |  Branch (928:6): [True: 2, False: 269]
  ------------------
  929|      2|		p->bufsize = total_length;
  930|    271|	p->buffer = malloc(p->bufsize);
  931|    271|	if (p->buffer == NULL) {
  ------------------
  |  Branch (931:6): [True: 0, False: 271]
  ------------------
  932|      0|		snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  933|      0|		free(p);
  934|      0|		*err = 1;
  935|      0|		return (NULL);
  936|      0|	}
  937|    271|	ps->max_blocksize = INITIAL_MAX_BLOCKSIZE;
  ------------------
  |  |  238|    271|#define INITIAL_MAX_BLOCKSIZE	(16*1024*1024)
  ------------------
  938|       |
  939|       |	/*
  940|       |	 * Copy the stuff we've read to the buffer, and read the rest
  941|       |	 * of the SHB.
  942|       |	 */
  943|    271|	bhdrp = (struct block_header *)p->buffer;
  944|    271|	shbp = (struct section_header_block *)(p->buffer + sizeof(struct block_header));
  945|    271|	bhdrp->block_type = magic_int;
  946|    271|	bhdrp->total_length = total_length;
  947|    271|	shbp->byte_order_magic = byte_order_magic;
  948|    271|	if (read_bytes(fp,
  ------------------
  |  Branch (948:6): [True: 2, False: 269]
  ------------------
  949|    271|	    p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
  950|    271|	    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
  951|    271|	    1, errbuf) == -1)
  952|      2|		goto fail;
  953|       |
  954|    269|	if (p->swapped) {
  ------------------
  |  Branch (954:6): [True: 12, False: 257]
  ------------------
  955|       |		/*
  956|       |		 * Byte-swap the fields we've read.
  957|       |		 */
  958|     12|		shbp->major_version = SWAPSHORT(shbp->major_version);
  ------------------
  |  |   59|     12|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|     12|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  959|     12|		shbp->minor_version = SWAPSHORT(shbp->minor_version);
  ------------------
  |  |   59|     12|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|     12|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  960|       |
  961|       |		/*
  962|       |		 * XXX - we don't care about the section length.
  963|       |		 */
  964|     12|	}
  965|       |	/* Currently only SHB versions 1.0 and 1.2 are supported;
  966|       |	   version 1.2 is treated as being the same as version 1.0.
  967|       |	   See the current version of the pcapng specification.
  968|       |
  969|       |	   Version 1.2 is written by some programs that write additional
  970|       |	   block types (which can be read by any code that handles them,
  971|       |	   regardless of whether the minor version if 0 or 2, so that's
  972|       |	   not a reason to change the minor version number).
  973|       |
  974|       |	   XXX - the pcapng specification says that readers should
  975|       |	   just ignore sections with an unsupported version number;
  976|       |	   presumably they can also report an error if they skip
  977|       |	   all the way to the end of the file without finding
  978|       |	   any versions that they support. */
  979|    269|	if (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&
  ------------------
  |  |  106|    538|#define PCAP_NG_VERSION_MAJOR	1
  ------------------
  |  Branch (979:9): [True: 267, False: 2]
  ------------------
  980|    269|	       (shbp->minor_version == PCAP_NG_VERSION_MINOR ||
  ------------------
  |  |  107|    534|#define PCAP_NG_VERSION_MINOR	0
  ------------------
  |  Branch (980:10): [True: 265, False: 2]
  ------------------
  981|    267|	        shbp->minor_version == 2))) {
  ------------------
  |  Branch (981:10): [True: 1, False: 1]
  ------------------
  982|      3|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      3|#define PCAP_ERRBUF_SIZE 256
  ------------------
  983|      3|		    "unsupported pcapng savefile version %u.%u",
  984|      3|		    shbp->major_version, shbp->minor_version);
  985|      3|		goto fail;
  986|      3|	}
  987|    266|	p->version_major = shbp->major_version;
  988|    266|	p->version_minor = shbp->minor_version;
  989|       |
  990|       |	/*
  991|       |	 * Save the time stamp resolution the user requested.
  992|       |	 */
  993|    266|	p->opt.tstamp_precision = precision;
  994|       |
  995|       |	/*
  996|       |	 * Now start looking for an Interface Description Block.
  997|       |	 */
  998|    315|	for (;;) {
  999|       |		/*
 1000|       |		 * Read the next block.
 1001|       |		 */
 1002|    315|		status = read_block(fp, p, &cursor, errbuf);
 1003|    315|		if (status == 0) {
  ------------------
  |  Branch (1003:7): [True: 6, False: 309]
  ------------------
 1004|       |			/* EOF - no IDB in this file */
 1005|      6|			snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      6|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1006|      6|			    "the capture file has no Interface Description Blocks");
 1007|      6|			goto fail;
 1008|      6|		}
 1009|    309|		if (status == -1)
  ------------------
  |  Branch (1009:7): [True: 24, False: 285]
  ------------------
 1010|     24|			goto fail;	/* error */
 1011|    285|		switch (cursor.block_type) {
 1012|       |
 1013|    233|		case BT_IDB:
  ------------------
  |  |  112|    233|#define BT_IDB			0x00000001
  ------------------
  |  Branch (1013:3): [True: 233, False: 52]
  ------------------
 1014|       |			/*
 1015|       |			 * Get a pointer to the fixed-length portion of the
 1016|       |			 * IDB.
 1017|       |			 */
 1018|    233|			idbp = get_from_block_data(&cursor, sizeof(*idbp),
 1019|    233|			    errbuf);
 1020|    233|			if (idbp == NULL)
  ------------------
  |  Branch (1020:8): [True: 0, False: 233]
  ------------------
 1021|      0|				goto fail;	/* error */
 1022|       |
 1023|       |			/*
 1024|       |			 * Byte-swap it if necessary.
 1025|       |			 */
 1026|    233|			if (p->swapped) {
  ------------------
  |  Branch (1026:8): [True: 4, False: 229]
  ------------------
 1027|      4|				idbp->linktype = SWAPSHORT(idbp->linktype);
  ------------------
  |  |   59|      4|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|      4|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
 1028|      4|				idbp->snaplen = SWAPLONG(idbp->snaplen);
  ------------------
  |  |   54|      4|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      4|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      4|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      4|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1029|      4|			}
 1030|       |
 1031|       |			/*
 1032|       |			 * Try to add this interface.
 1033|       |			 */
 1034|    233|			if (!add_interface(p, idbp, &cursor, errbuf))
  ------------------
  |  Branch (1034:8): [True: 14, False: 219]
  ------------------
 1035|     14|				goto fail;
 1036|       |
 1037|    219|			goto done;
 1038|       |
 1039|    219|		case BT_EPB:
  ------------------
  |  |  141|      1|#define BT_EPB			0x00000006
  ------------------
  |  Branch (1039:3): [True: 1, False: 284]
  ------------------
 1040|      2|		case BT_SPB:
  ------------------
  |  |  155|      2|#define BT_SPB			0x00000003
  ------------------
  |  Branch (1040:3): [True: 1, False: 284]
  ------------------
 1041|      3|		case BT_PB:
  ------------------
  |  |  165|      3|#define BT_PB			0x00000002
  ------------------
  |  Branch (1041:3): [True: 1, False: 284]
  ------------------
 1042|       |			/*
 1043|       |			 * Saw a packet before we saw any IDBs.  That's
 1044|       |			 * not valid, as we don't know what link-layer
 1045|       |			 * encapsulation the packet has.
 1046|       |			 */
 1047|      3|			snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      3|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1048|      3|			    "the capture file has a packet block before any Interface Description Blocks");
 1049|      3|			goto fail;
 1050|       |
 1051|     49|		default:
  ------------------
  |  Branch (1051:3): [True: 49, False: 236]
  ------------------
 1052|       |			/*
 1053|       |			 * Just ignore it.
 1054|       |			 */
 1055|     49|			break;
 1056|    285|		}
 1057|    285|	}
 1058|       |
 1059|    219|done:
 1060|    219|	p->linktype = linktype_to_dlt(idbp->linktype);
 1061|    219|	p->snapshot = pcapint_adjust_snapshot(p->linktype, idbp->snaplen);
 1062|    219|	p->linktype_ext = 0;
 1063|       |
 1064|       |	/*
 1065|       |	 * If the maximum block size for a packet with the maximum
 1066|       |	 * snapshot length for this DLT_ is bigger than the current
 1067|       |	 * maximum block size, increase the maximum.
 1068|       |	 */
 1069|    219|	if (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)
  ------------------
  |  |  246|    219|	(sizeof (struct block_header) + \
  |  |  247|    219|	 sizeof (struct enhanced_packet_block) + \
  |  |  248|    219|	 (max_snaplen) + 131072 + \
  |  |  249|    219|	 sizeof (struct block_trailer))
  ------------------
  |  Branch (1069:6): [True: 1, False: 218]
  ------------------
 1070|      1|		ps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));
  ------------------
  |  |  246|      1|	(sizeof (struct block_header) + \
  |  |  247|      1|	 sizeof (struct enhanced_packet_block) + \
  |  |  248|      1|	 (max_snaplen) + 131072 + \
  |  |  249|      1|	 sizeof (struct block_trailer))
  ------------------
 1071|       |
 1072|    219|	p->next_packet_op = pcap_ng_next_packet;
 1073|    219|	p->cleanup_op = pcap_ng_cleanup;
 1074|       |
 1075|    219|	return (p);
 1076|       |
 1077|     52|fail:
 1078|     52|	free(ps->ifaces);
 1079|     52|	free(p->buffer);
 1080|     52|	free(p);
 1081|     52|	*err = 1;
 1082|     52|	return (NULL);
 1083|    266|}
sf-pcapng.c:read_bytes:
  258|  7.81k|{
  259|  7.81k|	size_t amt_read;
  260|       |
  261|  7.81k|	amt_read = fread(buf, 1, bytes_to_read, fp);
  262|  7.81k|	if (amt_read != bytes_to_read) {
  ------------------
  |  Branch (262:6): [True: 184, False: 7.63k]
  ------------------
  263|    184|		if (ferror(fp)) {
  ------------------
  |  Branch (263:7): [True: 0, False: 184]
  ------------------
  264|      0|			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  265|      0|			    errno, "error reading dump file");
  266|    184|		} else {
  267|    184|			if (amt_read == 0 && !fail_on_eof)
  ------------------
  |  Branch (267:8): [True: 85, False: 99]
  |  Branch (267:25): [True: 76, False: 9]
  ------------------
  268|     76|				return (0);	/* EOF */
  269|    108|			snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|    108|#define PCAP_ERRBUF_SIZE 256
  ------------------
  270|    108|			    "truncated pcapng dump file; tried to read %zu bytes, only got %zu",
  271|    108|			    bytes_to_read, amt_read);
  272|    108|		}
  273|    108|		return (-1);
  274|    184|	}
  275|  7.63k|	return (1);
  276|  7.81k|}
sf-pcapng.c:read_block:
  280|  3.84k|{
  281|  3.84k|	struct pcap_ng_sf *ps;
  282|  3.84k|	int status;
  283|  3.84k|	struct block_header bhdr;
  284|  3.84k|	struct block_trailer *btrlr;
  285|  3.84k|	u_char *bdata;
  286|  3.84k|	size_t data_remaining;
  287|       |
  288|  3.84k|	ps = p->priv;
  289|       |
  290|  3.84k|	status = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);
  291|  3.84k|	if (status <= 0)
  ------------------
  |  Branch (291:6): [True: 116, False: 3.73k]
  ------------------
  292|    116|		return (status);	/* error or EOF */
  293|       |
  294|  3.73k|	if (p->swapped) {
  ------------------
  |  Branch (294:6): [True: 26, False: 3.70k]
  ------------------
  295|     26|		bhdr.block_type = SWAPLONG(bhdr.block_type);
  ------------------
  |  |   54|     26|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|     26|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|     26|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|     26|     ((((u_int)(y))>>24)&0xff))
  ------------------
  296|     26|		bhdr.total_length = SWAPLONG(bhdr.total_length);
  ------------------
  |  |   54|     26|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|     26|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|     26|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|     26|     ((((u_int)(y))>>24)&0xff))
  ------------------
  297|     26|	}
  298|       |
  299|       |	/*
  300|       |	 * Is this block "too small" - i.e., is it shorter than a block
  301|       |	 * header plus a block trailer?
  302|       |	 */
  303|  3.73k|	if (bhdr.total_length < sizeof(struct block_header) +
  ------------------
  |  Branch (303:6): [True: 5, False: 3.72k]
  ------------------
  304|  3.73k|	    sizeof(struct block_trailer)) {
  305|      5|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      5|#define PCAP_ERRBUF_SIZE 256
  ------------------
  306|      5|		    "block in pcapng dump file has a length of %u < %zu",
  307|      5|		    bhdr.total_length,
  308|      5|		    sizeof(struct block_header) + sizeof(struct block_trailer));
  309|      5|		return (-1);
  310|      5|	}
  311|       |
  312|       |	/*
  313|       |	 * Is the block total length a multiple of 4?
  314|       |	 */
  315|  3.72k|	if ((bhdr.total_length % 4) != 0) {
  ------------------
  |  Branch (315:6): [True: 16, False: 3.70k]
  ------------------
  316|       |		/*
  317|       |		 * No.  Report that as an error.
  318|       |		 */
  319|     16|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|     16|#define PCAP_ERRBUF_SIZE 256
  ------------------
  320|     16|		    "block in pcapng dump file has a length of %u that is not a multiple of 4",
  321|     16|		    bhdr.total_length);
  322|     16|		return (-1);
  323|     16|	}
  324|       |
  325|       |	/*
  326|       |	 * Is the buffer big enough?
  327|       |	 */
  328|  3.70k|	if (p->bufsize < bhdr.total_length) {
  ------------------
  |  Branch (328:6): [True: 66, False: 3.64k]
  ------------------
  329|       |		/*
  330|       |		 * No - make it big enough, unless it's too big, in
  331|       |		 * which case we fail.
  332|       |		 */
  333|     66|		void *bigger_buffer;
  334|       |
  335|     66|		if (bhdr.total_length > ps->max_blocksize) {
  ------------------
  |  Branch (335:7): [True: 9, False: 57]
  ------------------
  336|      9|			snprintf(errbuf, PCAP_ERRBUF_SIZE, "pcapng block size %u > maximum %u", bhdr.total_length,
  ------------------
  |  |  149|      9|#define PCAP_ERRBUF_SIZE 256
  ------------------
  337|      9|			    ps->max_blocksize);
  338|      9|			return (-1);
  339|      9|		}
  340|     57|		bigger_buffer = realloc(p->buffer, bhdr.total_length);
  341|     57|		if (bigger_buffer == NULL) {
  ------------------
  |  Branch (341:7): [True: 0, False: 57]
  ------------------
  342|      0|			snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  343|      0|			return (-1);
  344|      0|		}
  345|     57|		p->buffer = bigger_buffer;
  346|     57|	}
  347|       |
  348|       |	/*
  349|       |	 * Copy the stuff we've read to the buffer, and read the rest
  350|       |	 * of the block.
  351|       |	 */
  352|  3.70k|	memcpy(p->buffer, &bhdr, sizeof(bhdr));
  353|  3.70k|	bdata = p->buffer + sizeof(bhdr);
  354|  3.70k|	data_remaining = bhdr.total_length - sizeof(bhdr);
  355|  3.70k|	if (read_bytes(fp, bdata, data_remaining, 1, errbuf) == -1)
  ------------------
  |  Branch (355:6): [True: 66, False: 3.63k]
  ------------------
  356|     66|		return (-1);
  357|       |
  358|       |	/*
  359|       |	 * Get the block size from the trailer.
  360|       |	 */
  361|  3.63k|	btrlr = (struct block_trailer *)(bdata + data_remaining - sizeof (struct block_trailer));
  362|  3.63k|	if (p->swapped)
  ------------------
  |  Branch (362:6): [True: 24, False: 3.61k]
  ------------------
  363|     24|		btrlr->total_length = SWAPLONG(btrlr->total_length);
  ------------------
  |  |   54|     24|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|     24|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|     24|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|     24|     ((((u_int)(y))>>24)&0xff))
  ------------------
  364|       |
  365|       |	/*
  366|       |	 * Is the total length from the trailer the same as the total
  367|       |	 * length from the header?
  368|       |	 */
  369|  3.63k|	if (bhdr.total_length != btrlr->total_length) {
  ------------------
  |  Branch (369:6): [True: 18, False: 3.61k]
  ------------------
  370|       |		/*
  371|       |		 * No.
  372|       |		 */
  373|     18|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|     18|#define PCAP_ERRBUF_SIZE 256
  ------------------
  374|     18|		    "block total length in header and trailer don't match");
  375|     18|		return (-1);
  376|     18|	}
  377|       |
  378|       |	/*
  379|       |	 * Initialize the cursor.
  380|       |	 */
  381|  3.61k|	cursor->data = bdata;
  382|  3.61k|	cursor->data_remaining = data_remaining - sizeof(struct block_trailer);
  383|  3.61k|	cursor->block_type = bhdr.block_type;
  384|  3.61k|	return (1);
  385|  3.63k|}
sf-pcapng.c:get_from_block_data:
  390|  9.89k|{
  391|  9.89k|	void *data;
  392|       |
  393|       |	/*
  394|       |	 * Make sure we have the specified amount of data remaining in
  395|       |	 * the block data.
  396|       |	 */
  397|  9.89k|	if (cursor->data_remaining < chunk_size) {
  ------------------
  |  Branch (397:6): [True: 13, False: 9.87k]
  ------------------
  398|     13|		snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|     13|#define PCAP_ERRBUF_SIZE 256
  ------------------
  399|     13|		    "block of type %u in pcapng dump file is too short",
  400|     13|		    cursor->block_type);
  401|     13|		return (NULL);
  402|     13|	}
  403|       |
  404|       |	/*
  405|       |	 * Return the current pointer, and skip past the chunk.
  406|       |	 */
  407|  9.87k|	data = cursor->data;
  408|  9.87k|	cursor->data += chunk_size;
  409|  9.87k|	cursor->data_remaining -= chunk_size;
  410|  9.87k|	return (data);
  411|  9.89k|}
sf-pcapng.c:add_interface:
  593|  1.49k|{
  594|  1.49k|	struct pcap_ng_sf *ps;
  595|  1.49k|	uint64_t tsresol;
  596|  1.49k|	int64_t tsoffset;
  597|  1.49k|	int is_binary;
  598|       |
  599|  1.49k|	ps = p->priv;
  600|       |
  601|       |	/*
  602|       |	 * Count this interface.
  603|       |	 */
  604|  1.49k|	ps->ifcount++;
  605|       |
  606|       |	/*
  607|       |	 * Grow the array of per-interface information as necessary.
  608|       |	 */
  609|  1.49k|	if (ps->ifcount > ps->ifaces_size) {
  ------------------
  |  Branch (609:6): [True: 352, False: 1.13k]
  ------------------
  610|       |		/*
  611|       |		 * We need to grow the array.
  612|       |		 */
  613|    352|		bpf_u_int32 new_ifaces_size;
  614|    352|		struct pcap_ng_if *new_ifaces;
  615|       |
  616|    352|		if (ps->ifaces_size == 0) {
  ------------------
  |  Branch (616:7): [True: 233, False: 119]
  ------------------
  617|       |			/*
  618|       |			 * It's currently empty.
  619|       |			 *
  620|       |			 * (The Clang static analyzer doesn't do enough,
  621|       |			 * err, umm, dataflow *analysis* to realize that
  622|       |			 * ps->ifaces_size == 0 if ps->ifaces == NULL,
  623|       |			 * and so complains about a possible zero argument
  624|       |			 * to realloc(), so we check for the former
  625|       |			 * condition to shut it up.
  626|       |			 *
  627|       |			 * However, it doesn't complain that one of the
  628|       |			 * multiplications below could overflow, which is
  629|       |			 * a real, albeit extremely unlikely, problem (you'd
  630|       |			 * need a pcapng file with tens of millions of
  631|       |			 * interfaces).)
  632|       |			 */
  633|    233|			new_ifaces_size = 1;
  634|    233|			new_ifaces = malloc(sizeof (struct pcap_ng_if));
  635|    233|		} else {
  636|       |			/*
  637|       |			 * It's not currently empty; double its size.
  638|       |			 * (Perhaps overkill once we have a lot of interfaces.)
  639|       |			 *
  640|       |			 * Check for overflow if we double it.
  641|       |			 */
  642|    119|			if (ps->ifaces_size * 2 < ps->ifaces_size) {
  ------------------
  |  Branch (642:8): [True: 0, False: 119]
  ------------------
  643|       |				/*
  644|       |				 * The maximum number of interfaces before
  645|       |				 * ps->ifaces_size overflows is the largest
  646|       |				 * possible 32-bit power of 2, as we do
  647|       |				 * size doubling.
  648|       |				 */
  649|      0|				snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  650|      0|				    "more than %u interfaces in the file",
  651|      0|				    0x80000000U);
  652|      0|				return (0);
  653|      0|			}
  654|       |
  655|       |			/*
  656|       |			 * ps->ifaces_size * 2 doesn't overflow, so it's
  657|       |			 * safe to multiply.
  658|       |			 */
  659|    119|			new_ifaces_size = ps->ifaces_size * 2;
  660|       |
  661|       |			/*
  662|       |			 * Now make sure that's not so big that it overflows
  663|       |			 * if we multiply by sizeof (struct pcap_ng_if).
  664|       |			 *
  665|       |			 * That can happen on 32-bit platforms, with a 32-bit
  666|       |			 * size_t; it shouldn't happen on 64-bit platforms,
  667|       |			 * with a 64-bit size_t, as new_ifaces_size is
  668|       |			 * 32 bits.
  669|       |			 */
  670|    119|			if (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {
  ------------------
  |  Branch (670:8): [True: 0, False: 119]
  ------------------
  671|       |				/*
  672|       |				 * As this fails only with 32-bit size_t,
  673|       |				 * the multiplication was 32x32->32, and
  674|       |				 * the largest 32-bit value that can safely
  675|       |				 * be multiplied by sizeof (struct pcap_ng_if)
  676|       |				 * without overflow is the largest 32-bit
  677|       |				 * (unsigned) value divided by
  678|       |				 * sizeof (struct pcap_ng_if).
  679|       |				 */
  680|      0|				snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  681|      0|				    "more than %u interfaces in the file",
  682|      0|				    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));
  683|      0|				return (0);
  684|      0|			}
  685|    119|			new_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));
  686|    119|		}
  687|    352|		if (new_ifaces == NULL) {
  ------------------
  |  Branch (687:7): [True: 0, False: 352]
  ------------------
  688|       |			/*
  689|       |			 * We ran out of memory.
  690|       |			 * Give up.
  691|       |			 */
  692|      0|			snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      0|#define PCAP_ERRBUF_SIZE 256
  ------------------
  693|      0|			    "out of memory for per-interface information (%u interfaces)",
  694|      0|			    ps->ifcount);
  695|      0|			return (0);
  696|      0|		}
  697|    352|		ps->ifaces_size = new_ifaces_size;
  698|    352|		ps->ifaces = new_ifaces;
  699|    352|	}
  700|       |
  701|  1.49k|	ps->ifaces[ps->ifcount - 1].snaplen = idbp->snaplen;
  702|       |
  703|       |	/*
  704|       |	 * Set the default time stamp resolution and offset.
  705|       |	 */
  706|  1.49k|	tsresol = 1000000;	/* microsecond resolution */
  707|  1.49k|	is_binary = 0;		/* which is a power of 10 */
  708|  1.49k|	tsoffset = 0;		/* absolute timestamps */
  709|       |
  710|       |	/*
  711|       |	 * Now look for various time stamp options, so we know
  712|       |	 * how to interpret the time stamps for this interface.
  713|       |	 */
  714|  1.49k|	if (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,
  ------------------
  |  Branch (714:6): [True: 17, False: 1.47k]
  ------------------
  715|  1.49k|	    errbuf) == -1)
  716|     17|		return (0);
  717|       |
  718|  1.47k|	ps->ifaces[ps->ifcount - 1].tsresol = tsresol;
  719|  1.47k|	ps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;
  720|       |
  721|       |	/*
  722|       |	 * Determine whether we're scaling up or down or not
  723|       |	 * at all for this interface.
  724|       |	 */
  725|  1.47k|	if (tsresol == ps->user_tsresol) {
  ------------------
  |  Branch (725:6): [True: 766, False: 707]
  ------------------
  726|       |		/*
  727|       |		 * The resolution is the resolution the user wants,
  728|       |		 * so we don't have to do scaling.
  729|       |		 */
  730|    766|		ps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;
  731|    766|	} else if (tsresol > ps->user_tsresol) {
  ------------------
  |  Branch (731:13): [True: 62, False: 645]
  ------------------
  732|       |		/*
  733|       |		 * The resolution is greater than what the user wants,
  734|       |		 * so we have to scale the timestamps down.
  735|       |		 */
  736|     62|		if (is_binary)
  ------------------
  |  Branch (736:7): [True: 19, False: 43]
  ------------------
  737|     19|			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;
  738|     43|		else {
  739|       |			/*
  740|       |			 * Calculate the scale factor.
  741|       |			 */
  742|     43|			ps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;
  743|     43|			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;
  744|     43|		}
  745|    645|	} else {
  746|       |		/*
  747|       |		 * The resolution is less than what the user wants,
  748|       |		 * so we have to scale the timestamps up.
  749|       |		 */
  750|    645|		if (is_binary)
  ------------------
  |  Branch (750:7): [True: 619, False: 26]
  ------------------
  751|    619|			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;
  752|     26|		else {
  753|       |			/*
  754|       |			 * Calculate the scale factor.
  755|       |			 */
  756|     26|			ps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;
  757|     26|			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;
  758|     26|		}
  759|    645|	}
  760|  1.47k|	return (1);
  761|  1.49k|}
sf-pcapng.c:process_idb_options:
  462|  1.49k|{
  463|  1.49k|	struct option_header *opthdr;
  464|  1.49k|	void *optvalue;
  465|  1.49k|	int saw_tsresol, saw_tsoffset;
  466|  1.49k|	uint8_t tsresol_opt;
  467|  1.49k|	u_int i;
  468|       |
  469|  1.49k|	saw_tsresol = 0;
  470|  1.49k|	saw_tsoffset = 0;
  471|  3.67k|	while (cursor->data_remaining != 0) {
  ------------------
  |  Branch (471:9): [True: 2.48k, False: 1.19k]
  ------------------
  472|       |		/*
  473|       |		 * Get the option header.
  474|       |		 */
  475|  2.48k|		opthdr = get_opthdr_from_block_data(p, cursor, errbuf);
  476|  2.48k|		if (opthdr == NULL) {
  ------------------
  |  Branch (476:7): [True: 0, False: 2.48k]
  ------------------
  477|       |			/*
  478|       |			 * Option header is cut short.
  479|       |			 */
  480|      0|			return (-1);
  481|      0|		}
  482|       |
  483|       |		/*
  484|       |		 * Get option value.
  485|       |		 */
  486|  2.48k|		optvalue = get_optvalue_from_block_data(cursor, opthdr,
  487|  2.48k|		    errbuf);
  488|  2.48k|		if (optvalue == NULL) {
  ------------------
  |  Branch (488:7): [True: 8, False: 2.47k]
  ------------------
  489|       |			/*
  490|       |			 * Option value is cut short.
  491|       |			 */
  492|      8|			return (-1);
  493|      8|		}
  494|       |
  495|  2.47k|		switch (opthdr->option_code) {
  496|       |
  497|    284|		case OPT_ENDOFOPT:
  ------------------
  |  |   67|    284|#define OPT_ENDOFOPT	0	/* end of options */
  ------------------
  |  Branch (497:3): [True: 284, False: 2.19k]
  ------------------
  498|    284|			if (opthdr->option_length != 0) {
  ------------------
  |  Branch (498:8): [True: 1, False: 283]
  ------------------
  499|      1|				snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
  500|      1|				    "Interface Description Block has opt_endofopt option with length %u != 0",
  501|      1|				    opthdr->option_length);
  502|      1|				return (-1);
  503|      1|			}
  504|    283|			goto done;
  505|       |
  506|    782|		case IF_TSRESOL:
  ------------------
  |  |  131|    782|#define IF_TSRESOL	9	/* interface's time stamp resolution */
  ------------------
  |  Branch (506:3): [True: 782, False: 1.69k]
  ------------------
  507|    782|			if (opthdr->option_length != 1) {
  ------------------
  |  Branch (507:8): [True: 2, False: 780]
  ------------------
  508|      2|				snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      2|#define PCAP_ERRBUF_SIZE 256
  ------------------
  509|      2|				    "Interface Description Block has if_tsresol option with length %u != 1",
  510|      2|				    opthdr->option_length);
  511|      2|				return (-1);
  512|      2|			}
  513|    780|			if (saw_tsresol) {
  ------------------
  |  Branch (513:8): [True: 1, False: 779]
  ------------------
  514|      1|				snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
  515|      1|				    "Interface Description Block has more than one if_tsresol option");
  516|      1|				return (-1);
  517|      1|			}
  518|    779|			saw_tsresol = 1;
  519|    779|			memcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));
  520|    779|			if (tsresol_opt & 0x80) {
  ------------------
  |  Branch (520:8): [True: 640, False: 139]
  ------------------
  521|       |				/*
  522|       |				 * Resolution is negative power of 2.
  523|       |				 */
  524|    640|				uint8_t tsresol_shift = (tsresol_opt & 0x7F);
  525|       |
  526|    640|				if (tsresol_shift > 63) {
  ------------------
  |  Branch (526:9): [True: 1, False: 639]
  ------------------
  527|       |					/*
  528|       |					 * Resolution is too high; 2^-{res}
  529|       |					 * won't fit in a 64-bit value.
  530|       |					 */
  531|      1|					snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
  532|      1|					    "Interface Description Block if_tsresol option resolution 2^-%u is too high",
  533|      1|					    tsresol_shift);
  534|      1|					return (-1);
  535|      1|				}
  536|    639|				*is_binary = 1;
  537|    639|				*tsresol = ((uint64_t)1) << tsresol_shift;
  538|    639|			} else {
  539|       |				/*
  540|       |				 * Resolution is negative power of 10.
  541|       |				 */
  542|    139|				if (tsresol_opt > 19) {
  ------------------
  |  Branch (542:9): [True: 2, False: 137]
  ------------------
  543|       |					/*
  544|       |					 * Resolution is too high; 2^-{res}
  545|       |					 * won't fit in a 64-bit value (the
  546|       |					 * largest power of 10 that fits
  547|       |					 * in a 64-bit value is 10^19, as
  548|       |					 * the largest 64-bit unsigned
  549|       |					 * value is ~1.8*10^19).
  550|       |					 */
  551|      2|					snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      2|#define PCAP_ERRBUF_SIZE 256
  ------------------
  552|      2|					    "Interface Description Block if_tsresol option resolution 10^-%u is too high",
  553|      2|					    tsresol_opt);
  554|      2|					return (-1);
  555|      2|				}
  556|    137|				*is_binary = 0;
  557|    137|				*tsresol = 1;
  558|    959|				for (i = 0; i < tsresol_opt; i++)
  ------------------
  |  Branch (558:17): [True: 822, False: 137]
  ------------------
  559|    822|					*tsresol *= 10;
  560|    137|			}
  561|    776|			break;
  562|       |
  563|    776|		case IF_TSOFFSET:
  ------------------
  |  |  136|      4|#define IF_TSOFFSET	14	/* time stamp offset for this interface */
  ------------------
  |  Branch (563:3): [True: 4, False: 2.47k]
  ------------------
  564|      4|			if (opthdr->option_length != 8) {
  ------------------
  |  Branch (564:8): [True: 1, False: 3]
  ------------------
  565|      1|				snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
  566|      1|				    "Interface Description Block has if_tsoffset option with length %u != 8",
  567|      1|				    opthdr->option_length);
  568|      1|				return (-1);
  569|      1|			}
  570|      3|			if (saw_tsoffset) {
  ------------------
  |  Branch (570:8): [True: 1, False: 2]
  ------------------
  571|      1|				snprintf(errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
  572|      1|				    "Interface Description Block has more than one if_tsoffset option");
  573|      1|				return (-1);
  574|      1|			}
  575|      2|			saw_tsoffset = 1;
  576|      2|			memcpy(tsoffset, optvalue, sizeof(*tsoffset));
  577|      2|			if (p->swapped)
  ------------------
  |  Branch (577:8): [True: 0, False: 2]
  ------------------
  578|      0|				*tsoffset = SWAPLL(*tsoffset);
  ------------------
  |  |   45|      0|#define SWAPLL(y)  ((((uint64_t)(y) & 0xff00000000000000ULL) >> 56) | \
  |  |   46|      0|                      (((uint64_t)(y) & 0x00ff000000000000ULL) >> 40) | \
  |  |   47|      0|                      (((uint64_t)(y) & 0x0000ff0000000000ULL) >> 24) | \
  |  |   48|      0|                      (((uint64_t)(y) & 0x000000ff00000000ULL) >> 8)  | \
  |  |   49|      0|                      (((uint64_t)(y) & 0x00000000ff000000ULL) << 8)  | \
  |  |   50|      0|                      (((uint64_t)(y) & 0x0000000000ff0000ULL) << 24) | \
  |  |   51|      0|                      (((uint64_t)(y) & 0x000000000000ff00ULL) << 40) | \
  |  |   52|      0|                      (((uint64_t)(y) & 0x00000000000000ffULL) << 56))
  ------------------
  579|      2|			break;
  580|       |
  581|  1.40k|		default:
  ------------------
  |  Branch (581:3): [True: 1.40k, False: 1.07k]
  ------------------
  582|  1.40k|			break;
  583|  2.47k|		}
  584|  2.47k|	}
  585|       |
  586|  1.47k|done:
  587|  1.47k|	return (0);
  588|  1.49k|}
sf-pcapng.c:get_opthdr_from_block_data:
  415|  2.48k|{
  416|  2.48k|	struct option_header *opthdr;
  417|       |
  418|  2.48k|	opthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);
  419|  2.48k|	if (opthdr == NULL) {
  ------------------
  |  Branch (419:6): [True: 0, False: 2.48k]
  ------------------
  420|       |		/*
  421|       |		 * Option header is cut short.
  422|       |		 */
  423|      0|		return (NULL);
  424|      0|	}
  425|       |
  426|       |	/*
  427|       |	 * Byte-swap it if necessary.
  428|       |	 */
  429|  2.48k|	if (p->swapped) {
  ------------------
  |  Branch (429:6): [True: 10, False: 2.47k]
  ------------------
  430|     10|		opthdr->option_code = SWAPSHORT(opthdr->option_code);
  ------------------
  |  |   59|     10|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|     10|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  431|     10|		opthdr->option_length = SWAPSHORT(opthdr->option_length);
  ------------------
  |  |   59|     10|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|     10|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
  432|     10|	}
  433|       |
  434|  2.48k|	return (opthdr);
  435|  2.48k|}
sf-pcapng.c:get_optvalue_from_block_data:
  440|  2.48k|{
  441|  2.48k|	size_t padded_option_len;
  442|  2.48k|	void *optvalue;
  443|       |
  444|       |	/* Pad option length to 4-byte boundary */
  445|  2.48k|	padded_option_len = opthdr->option_length;
  446|  2.48k|	padded_option_len = ((padded_option_len + 3)/4)*4;
  447|       |
  448|  2.48k|	optvalue = get_from_block_data(cursor, padded_option_len, errbuf);
  449|  2.48k|	if (optvalue == NULL) {
  ------------------
  |  Branch (449:6): [True: 8, False: 2.47k]
  ------------------
  450|       |		/*
  451|       |		 * Option value is cut short.
  452|       |		 */
  453|      8|		return (NULL);
  454|      8|	}
  455|       |
  456|  2.47k|	return (optvalue);
  457|  2.48k|}
sf-pcapng.c:pcap_ng_cleanup:
 1087|    219|{
 1088|    219|	struct pcap_ng_sf *ps = p->priv;
 1089|       |
 1090|    219|	free(ps->ifaces);
 1091|    219|	pcapint_sf_cleanup(p);
 1092|    219|}
sf-pcapng.c:pcap_ng_next_packet:
 1101|  1.68k|{
 1102|  1.68k|	struct pcap_ng_sf *ps = p->priv;
 1103|  1.68k|	struct block_cursor cursor;
 1104|  1.68k|	int status;
 1105|  1.68k|	struct enhanced_packet_block *epbp;
 1106|  1.68k|	struct simple_packet_block *spbp;
 1107|  1.68k|	struct packet_block *pbp;
 1108|  1.68k|	bpf_u_int32 interface_id = 0xFFFFFFFF;
 1109|  1.68k|	struct interface_description_block *idbp;
 1110|  1.68k|	struct section_header_block *shbp;
 1111|  1.68k|	FILE *fp = p->rfile;
 1112|  1.68k|	uint64_t t, sec, frac;
 1113|       |
 1114|       |	/*
 1115|       |	 * Look for an Enhanced Packet Block, a Simple Packet Block,
 1116|       |	 * or a Packet Block.
 1117|       |	 */
 1118|  3.53k|	for (;;) {
 1119|       |		/*
 1120|       |		 * Read the block type and length; those are common
 1121|       |		 * to all blocks.
 1122|       |		 */
 1123|  3.53k|		status = read_block(fp, p, &cursor, p->errbuf);
 1124|  3.53k|		if (status == 0)
  ------------------
  |  Branch (1124:7): [True: 70, False: 3.46k]
  ------------------
 1125|     70|			return (0);	/* EOF */
 1126|  3.46k|		if (status == -1)
  ------------------
  |  Branch (1126:7): [True: 130, False: 3.33k]
  ------------------
 1127|    130|			return (-1);	/* error */
 1128|  3.33k|		switch (cursor.block_type) {
 1129|       |
 1130|  1.45k|		case BT_EPB:
  ------------------
  |  |  141|  1.45k|#define BT_EPB			0x00000006
  ------------------
  |  Branch (1130:3): [True: 1.45k, False: 1.87k]
  ------------------
 1131|       |			/*
 1132|       |			 * Get a pointer to the fixed-length portion of the
 1133|       |			 * EPB.
 1134|       |			 */
 1135|  1.45k|			epbp = get_from_block_data(&cursor, sizeof(*epbp),
 1136|  1.45k|			    p->errbuf);
 1137|  1.45k|			if (epbp == NULL)
  ------------------
  |  Branch (1137:8): [True: 1, False: 1.45k]
  ------------------
 1138|      1|				return (-1);	/* error */
 1139|       |
 1140|       |			/*
 1141|       |			 * Byte-swap it if necessary.
 1142|       |			 */
 1143|  1.45k|			if (p->swapped) {
  ------------------
  |  Branch (1143:8): [True: 0, False: 1.45k]
  ------------------
 1144|       |				/* these were written in opposite byte order */
 1145|      0|				interface_id = SWAPLONG(epbp->interface_id);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1146|      0|				hdr->caplen = SWAPLONG(epbp->caplen);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1147|      0|				hdr->len = SWAPLONG(epbp->len);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1148|      0|				t = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1149|      0|				    SWAPLONG(epbp->timestamp_low);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1150|  1.45k|			} else {
 1151|  1.45k|				interface_id = epbp->interface_id;
 1152|  1.45k|				hdr->caplen = epbp->caplen;
 1153|  1.45k|				hdr->len = epbp->len;
 1154|  1.45k|				t = ((uint64_t)epbp->timestamp_high) << 32 |
 1155|  1.45k|				    epbp->timestamp_low;
 1156|  1.45k|			}
 1157|  1.45k|			goto found;
 1158|       |
 1159|     11|		case BT_SPB:
  ------------------
  |  |  155|     11|#define BT_SPB			0x00000003
  ------------------
  |  Branch (1159:3): [True: 11, False: 3.32k]
  ------------------
 1160|       |			/*
 1161|       |			 * Get a pointer to the fixed-length portion of the
 1162|       |			 * SPB.
 1163|       |			 */
 1164|     11|			spbp = get_from_block_data(&cursor, sizeof(*spbp),
 1165|     11|			    p->errbuf);
 1166|     11|			if (spbp == NULL)
  ------------------
  |  Branch (1166:8): [True: 0, False: 11]
  ------------------
 1167|      0|				return (-1);	/* error */
 1168|       |
 1169|       |			/*
 1170|       |			 * SPB packets are assumed to have arrived on
 1171|       |			 * the first interface.
 1172|       |			 */
 1173|     11|			interface_id = 0;
 1174|       |
 1175|       |			/*
 1176|       |			 * Byte-swap it if necessary.
 1177|       |			 */
 1178|     11|			if (p->swapped) {
  ------------------
  |  Branch (1178:8): [True: 0, False: 11]
  ------------------
 1179|       |				/* these were written in opposite byte order */
 1180|      0|				hdr->len = SWAPLONG(spbp->len);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1181|      0|			} else
 1182|     11|				hdr->len = spbp->len;
 1183|       |
 1184|       |			/*
 1185|       |			 * The SPB doesn't give the captured length;
 1186|       |			 * it's the minimum of the snapshot length
 1187|       |			 * and the packet length.
 1188|       |			 */
 1189|     11|			hdr->caplen = hdr->len;
 1190|     11|			if (hdr->caplen > (bpf_u_int32)p->snapshot)
  ------------------
  |  Branch (1190:8): [True: 1, False: 10]
  ------------------
 1191|      1|				hdr->caplen = p->snapshot;
 1192|     11|			t = 0;	/* no time stamps */
 1193|     11|			goto found;
 1194|       |
 1195|      2|		case BT_PB:
  ------------------
  |  |  165|      2|#define BT_PB			0x00000002
  ------------------
  |  Branch (1195:3): [True: 2, False: 3.32k]
  ------------------
 1196|       |			/*
 1197|       |			 * Get a pointer to the fixed-length portion of the
 1198|       |			 * PB.
 1199|       |			 */
 1200|      2|			pbp = get_from_block_data(&cursor, sizeof(*pbp),
 1201|      2|			    p->errbuf);
 1202|      2|			if (pbp == NULL)
  ------------------
  |  Branch (1202:8): [True: 1, False: 1]
  ------------------
 1203|      1|				return (-1);	/* error */
 1204|       |
 1205|       |			/*
 1206|       |			 * Byte-swap it if necessary.
 1207|       |			 */
 1208|      1|			if (p->swapped) {
  ------------------
  |  Branch (1208:8): [True: 0, False: 1]
  ------------------
 1209|       |				/* these were written in opposite byte order */
 1210|      0|				interface_id = SWAPSHORT(pbp->interface_id);
  ------------------
  |  |   59|      0|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|      0|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
 1211|      0|				hdr->caplen = SWAPLONG(pbp->caplen);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1212|      0|				hdr->len = SWAPLONG(pbp->len);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1213|      0|				t = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1214|      0|				    SWAPLONG(pbp->timestamp_low);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1215|      1|			} else {
 1216|      1|				interface_id = pbp->interface_id;
 1217|      1|				hdr->caplen = pbp->caplen;
 1218|      1|				hdr->len = pbp->len;
 1219|      1|				t = ((uint64_t)pbp->timestamp_high) << 32 |
 1220|      1|				    pbp->timestamp_low;
 1221|      1|			}
 1222|      1|			goto found;
 1223|       |
 1224|  1.26k|		case BT_IDB:
  ------------------
  |  |  112|  1.26k|#define BT_IDB			0x00000001
  ------------------
  |  Branch (1224:3): [True: 1.26k, False: 2.06k]
  ------------------
 1225|       |			/*
 1226|       |			 * Interface Description Block.  Get a pointer
 1227|       |			 * to its fixed-length portion.
 1228|       |			 */
 1229|  1.26k|			idbp = get_from_block_data(&cursor, sizeof(*idbp),
 1230|  1.26k|			    p->errbuf);
 1231|  1.26k|			if (idbp == NULL)
  ------------------
  |  Branch (1231:8): [True: 0, False: 1.26k]
  ------------------
 1232|      0|				return (-1);	/* error */
 1233|       |
 1234|       |			/*
 1235|       |			 * Byte-swap it if necessary.
 1236|       |			 */
 1237|  1.26k|			if (p->swapped) {
  ------------------
  |  Branch (1237:8): [True: 0, False: 1.26k]
  ------------------
 1238|      0|				idbp->linktype = SWAPSHORT(idbp->linktype);
  ------------------
  |  |   59|      0|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|      0|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
 1239|      0|				idbp->snaplen = SWAPLONG(idbp->snaplen);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1240|      0|			}
 1241|       |
 1242|       |			/*
 1243|       |			 * If the link-layer type or snapshot length
 1244|       |			 * differ from the ones for the first IDB we
 1245|       |			 * saw, quit.
 1246|       |			 *
 1247|       |			 * XXX - just discard packets from those
 1248|       |			 * interfaces?
 1249|       |			 */
 1250|  1.26k|			if (p->linktype != idbp->linktype) {
  ------------------
  |  Branch (1250:8): [True: 4, False: 1.25k]
  ------------------
 1251|      4|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      4|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1252|      4|				    "an interface has a type %u different from the type of the first interface",
 1253|      4|				    idbp->linktype);
 1254|      4|				return (-1);
 1255|      4|			}
 1256|       |
 1257|       |			/*
 1258|       |			 * Check against the *adjusted* value of this IDB's
 1259|       |			 * snapshot length.
 1260|       |			 */
 1261|  1.25k|			if ((bpf_u_int32)p->snapshot !=
  ------------------
  |  Branch (1261:8): [True: 1, False: 1.25k]
  ------------------
 1262|  1.25k|			    pcapint_adjust_snapshot(p->linktype, idbp->snaplen)) {
 1263|      1|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1264|      1|				    "an interface has a snapshot length %u different from the snapshot length of the first interface",
 1265|      1|				    idbp->snaplen);
 1266|      1|				return (-1);
 1267|      1|			}
 1268|       |
 1269|       |			/*
 1270|       |			 * Try to add this interface.
 1271|       |			 */
 1272|  1.25k|			if (!add_interface(p, idbp, &cursor, p->errbuf))
  ------------------
  |  Branch (1272:8): [True: 3, False: 1.25k]
  ------------------
 1273|      3|				return (-1);
 1274|  1.25k|			break;
 1275|       |
 1276|  1.25k|		case BT_SHB:
  ------------------
  |  |   86|    494|#define BT_SHB			0x0A0D0D0A
  ------------------
  |  Branch (1276:3): [True: 494, False: 2.83k]
  ------------------
 1277|       |			/*
 1278|       |			 * Section Header Block.  Get a pointer
 1279|       |			 * to its fixed-length portion.
 1280|       |			 */
 1281|    494|			shbp = get_from_block_data(&cursor, sizeof(*shbp),
 1282|    494|			    p->errbuf);
 1283|    494|			if (shbp == NULL)
  ------------------
  |  Branch (1283:8): [True: 1, False: 493]
  ------------------
 1284|      1|				return (-1);	/* error */
 1285|       |
 1286|       |			/*
 1287|       |			 * Assume the byte order of this section is
 1288|       |			 * the same as that of the previous section.
 1289|       |			 * We'll check for that later.
 1290|       |			 */
 1291|    493|			if (p->swapped) {
  ------------------
  |  Branch (1291:8): [True: 0, False: 493]
  ------------------
 1292|      0|				shbp->byte_order_magic =
 1293|      0|				    SWAPLONG(shbp->byte_order_magic);
  ------------------
  |  |   54|      0|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      0|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      0|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      0|     ((((u_int)(y))>>24)&0xff))
  ------------------
 1294|      0|				shbp->major_version =
 1295|      0|				    SWAPSHORT(shbp->major_version);
  ------------------
  |  |   59|      0|     ((u_short)(((((u_int)(y))&0xff)<<8) | \
  |  |   60|      0|                ((((u_int)(y))&0xff00)>>8)))
  ------------------
 1296|      0|			}
 1297|       |
 1298|       |			/*
 1299|       |			 * Make sure the byte order doesn't change;
 1300|       |			 * pcap_is_swapped() shouldn't change its
 1301|       |			 * return value in the middle of reading a capture.
 1302|       |			 */
 1303|    493|			switch (shbp->byte_order_magic) {
 1304|       |
 1305|    491|			case BYTE_ORDER_MAGIC:
  ------------------
  |  |   99|    491|#define BYTE_ORDER_MAGIC	0x1A2B3C4D
  ------------------
  |  Branch (1305:4): [True: 491, False: 2]
  ------------------
 1306|       |				/*
 1307|       |				 * OK.
 1308|       |				 */
 1309|    491|				break;
 1310|       |
 1311|      1|			case SWAPLONG(BYTE_ORDER_MAGIC):
  ------------------
  |  |   54|      1|    (((((u_int)(y))&0xff)<<24) | \
  |  |   55|      1|     ((((u_int)(y))&0xff00)<<8) | \
  |  |   56|      1|     ((((u_int)(y))&0xff0000)>>8) | \
  |  |   57|      1|     ((((u_int)(y))>>24)&0xff))
  ------------------
  |  Branch (1311:4): [True: 1, False: 492]
  ------------------
 1312|       |				/*
 1313|       |				 * Byte order changes.
 1314|       |				 */
 1315|      1|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1316|      1|				    "the file has sections with different byte orders");
 1317|      1|				return (-1);
 1318|       |
 1319|      1|			default:
  ------------------
  |  Branch (1319:4): [True: 1, False: 492]
  ------------------
 1320|       |				/*
 1321|       |				 * Not a valid SHB.
 1322|       |				 */
 1323|      1|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1324|      1|				    "the file has a section with a bad byte order magic field");
 1325|      1|				return (-1);
 1326|    493|			}
 1327|       |
 1328|       |			/*
 1329|       |			 * Make sure the major version is the version
 1330|       |			 * we handle.
 1331|       |			 */
 1332|    491|			if (shbp->major_version != PCAP_NG_VERSION_MAJOR) {
  ------------------
  |  |  106|    491|#define PCAP_NG_VERSION_MAJOR	1
  ------------------
  |  Branch (1332:8): [True: 1, False: 490]
  ------------------
 1333|      1|				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1334|      1|				    "unknown pcapng savefile major version number %u",
 1335|      1|				    shbp->major_version);
 1336|      1|				return (-1);
 1337|      1|			}
 1338|       |
 1339|       |			/*
 1340|       |			 * Reset the interface count; this section should
 1341|       |			 * have its own set of IDBs.  If any of them
 1342|       |			 * don't have the same interface type, snapshot
 1343|       |			 * length, or resolution as the first interface
 1344|       |			 * we saw, we'll fail.  (And if we don't see
 1345|       |			 * any IDBs, we'll fail when we see a packet
 1346|       |			 * block.)
 1347|       |			 */
 1348|    490|			ps->ifcount = 0;
 1349|    490|			break;
 1350|       |
 1351|    107|		default:
  ------------------
  |  Branch (1351:3): [True: 107, False: 3.22k]
  ------------------
 1352|       |			/*
 1353|       |			 * Not a packet block, IDB, or SHB; ignore it.
 1354|       |			 */
 1355|    107|			break;
 1356|  3.33k|		}
 1357|  3.33k|	}
 1358|       |
 1359|  1.46k|found:
 1360|       |	/*
 1361|       |	 * Is the interface ID an interface we know?
 1362|       |	 */
 1363|  1.46k|	if (interface_id >= ps->ifcount) {
  ------------------
  |  Branch (1363:6): [True: 2, False: 1.46k]
  ------------------
 1364|       |		/*
 1365|       |		 * Yes.  Fail.
 1366|       |		 */
 1367|      2|		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      2|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1368|      2|		    "a packet arrived on interface %u, but there's no Interface Description Block for that interface",
 1369|      2|		    interface_id);
 1370|      2|		return (-1);
 1371|      2|	}
 1372|       |
 1373|  1.46k|	if (hdr->caplen > (bpf_u_int32)p->snapshot) {
  ------------------
  |  Branch (1373:6): [True: 1, False: 1.46k]
  ------------------
 1374|      1|		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
  ------------------
  |  |  149|      1|#define PCAP_ERRBUF_SIZE 256
  ------------------
 1375|      1|		    "invalid packet capture length %u, bigger than "
 1376|      1|		    "snaplen of %d", hdr->caplen, p->snapshot);
 1377|      1|		return (-1);
 1378|      1|	}
 1379|       |
 1380|       |	/*
 1381|       |	 * Convert the time stamp to seconds and fractions of a second,
 1382|       |	 * with the fractions being in units of the file-supplied resolution.
 1383|       |	 */
 1384|  1.46k|	sec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;
 1385|  1.46k|	frac = t % ps->ifaces[interface_id].tsresol;
 1386|       |
 1387|       |	/*
 1388|       |	 * Convert the fractions from units of the file-supplied resolution
 1389|       |	 * to units of the user-requested resolution.
 1390|       |	 */
 1391|  1.46k|	switch (ps->ifaces[interface_id].scale_type) {
  ------------------
  |  Branch (1391:10): [True: 0, False: 1.46k]
  ------------------
 1392|       |
 1393|  1.01k|	case PASS_THROUGH:
  ------------------
  |  Branch (1393:2): [True: 1.01k, False: 452]
  ------------------
 1394|       |		/*
 1395|       |		 * The interface resolution is what the user wants,
 1396|       |		 * so we're done.
 1397|       |		 */
 1398|  1.01k|		break;
 1399|       |
 1400|    201|	case SCALE_UP_DEC:
  ------------------
  |  Branch (1400:2): [True: 201, False: 1.26k]
  ------------------
 1401|       |		/*
 1402|       |		 * The interface resolution is less than what the user
 1403|       |		 * wants; scale the fractional part up to the units of
 1404|       |		 * the resolution the user requested by multiplying by
 1405|       |		 * the quotient of the user-requested resolution and the
 1406|       |		 * file-supplied resolution.
 1407|       |		 *
 1408|       |		 * Those resolutions are both powers of 10, and the user-
 1409|       |		 * requested resolution is greater than the file-supplied
 1410|       |		 * resolution, so the quotient in question is an integer.
 1411|       |		 * We've calculated that quotient already, so we just
 1412|       |		 * multiply by it.
 1413|       |		 */
 1414|    201|		frac *= ps->ifaces[interface_id].scale_factor;
 1415|    201|		break;
 1416|       |
 1417|     66|	case SCALE_UP_BIN:
  ------------------
  |  Branch (1417:2): [True: 66, False: 1.39k]
  ------------------
 1418|       |		/*
 1419|       |		 * The interface resolution is less than what the user
 1420|       |		 * wants; scale the fractional part up to the units of
 1421|       |		 * the resolution the user requested by multiplying by
 1422|       |		 * the quotient of the user-requested resolution and the
 1423|       |		 * file-supplied resolution.
 1424|       |		 *
 1425|       |		 * The file-supplied resolution is a power of 2, so the
 1426|       |		 * quotient is not an integer, so, in order to do this
 1427|       |		 * entirely with integer arithmetic, we multiply by the
 1428|       |		 * user-requested resolution and divide by the file-
 1429|       |		 * supplied resolution.
 1430|       |		 *
 1431|       |		 * XXX - Is there something clever we could do here,
 1432|       |		 * given that we know that the file-supplied resolution
 1433|       |		 * is a power of 2?  Doing a multiplication followed by
 1434|       |		 * a division runs the risk of overflowing, and involves
 1435|       |		 * two non-simple arithmetic operations.
 1436|       |		 */
 1437|     66|		frac *= ps->user_tsresol;
 1438|     66|		frac /= ps->ifaces[interface_id].tsresol;
 1439|     66|		break;
 1440|       |
 1441|    118|	case SCALE_DOWN_DEC:
  ------------------
  |  Branch (1441:2): [True: 118, False: 1.34k]
  ------------------
 1442|       |		/*
 1443|       |		 * The interface resolution is greater than what the user
 1444|       |		 * wants; scale the fractional part up to the units of
 1445|       |		 * the resolution the user requested by multiplying by
 1446|       |		 * the quotient of the user-requested resolution and the
 1447|       |		 * file-supplied resolution.
 1448|       |		 *
 1449|       |		 * Those resolutions are both powers of 10, and the user-
 1450|       |		 * requested resolution is less than the file-supplied
 1451|       |		 * resolution, so the quotient in question isn't an
 1452|       |		 * integer, but its reciprocal is, and we can just divide
 1453|       |		 * by the reciprocal of the quotient.  We've calculated
 1454|       |		 * the reciprocal of that quotient already, so we must
 1455|       |		 * divide by it.
 1456|       |		 */
 1457|    118|		frac /= ps->ifaces[interface_id].scale_factor;
 1458|    118|		break;
 1459|       |
 1460|       |
 1461|     67|	case SCALE_DOWN_BIN:
  ------------------
  |  Branch (1461:2): [True: 67, False: 1.39k]
  ------------------
 1462|       |		/*
 1463|       |		 * The interface resolution is greater than what the user
 1464|       |		 * wants; convert the fractional part to units of the
 1465|       |		 * resolution the user requested by multiplying by the
 1466|       |		 * quotient of the user-requested resolution and the
 1467|       |		 * file-supplied resolution.  We do that by multiplying
 1468|       |		 * by the user-requested resolution and dividing by the
 1469|       |		 * file-supplied resolution, as the quotient might not
 1470|       |		 * fit in an integer.
 1471|       |		 *
 1472|       |		 * The file-supplied resolution is a power of 2, so the
 1473|       |		 * quotient is not an integer, and neither is its
 1474|       |		 * reciprocal, so, in order to do this entirely with
 1475|       |		 * integer arithmetic, we multiply by the user-requested
 1476|       |		 * resolution and divide by the file-supplied resolution.
 1477|       |		 *
 1478|       |		 * XXX - Is there something clever we could do here,
 1479|       |		 * given that we know that the file-supplied resolution
 1480|       |		 * is a power of 2?  Doing a multiplication followed by
 1481|       |		 * a division runs the risk of overflowing, and involves
 1482|       |		 * two non-simple arithmetic operations.
 1483|       |		 */
 1484|     67|		frac *= ps->user_tsresol;
 1485|     67|		frac /= ps->ifaces[interface_id].tsresol;
 1486|     67|		break;
 1487|  1.46k|	}
 1488|       |#ifdef _WIN32
 1489|       |	/*
 1490|       |	 * tv_sec and tv_usec in the Windows struct timeval are both
 1491|       |	 * longs.
 1492|       |	 */
 1493|       |	hdr->ts.tv_sec = (long)sec;
 1494|       |	hdr->ts.tv_usec = (long)frac;
 1495|       |#else
 1496|       |	/*
 1497|       |	 * tv_sec in the UN*X struct timeval is a time_t; tv_usec is
 1498|       |	 * suseconds_t in UN*Xes that work the way the current Single
 1499|       |	 * UNIX Standard specify - but not all older UN*Xes necessarily
 1500|       |	 * support that type, so just cast to int.
 1501|       |	 */
 1502|  1.46k|	hdr->ts.tv_sec = (time_t)sec;
 1503|  1.46k|	hdr->ts.tv_usec = (int)frac;
 1504|  1.46k|#endif
 1505|       |
 1506|       |	/*
 1507|       |	 * Get a pointer to the packet data.
 1508|       |	 */
 1509|  1.46k|	*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);
 1510|  1.46k|	if (*data == NULL)
  ------------------
  |  Branch (1510:6): [True: 2, False: 1.46k]
  ------------------
 1511|      2|		return (-1);
 1512|       |
 1513|  1.46k|	pcapint_post_process(p->linktype, p->swapped, hdr, *data);
 1514|       |
 1515|  1.46k|	return (1);
 1516|  1.46k|}

LLVMFuzzerTestOneInput:
   40|  2.72k|int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
   41|  2.72k|    pcap_t * pkts;
   42|  2.72k|    char errbuf[PCAP_ERRBUF_SIZE];
   43|  2.72k|    char filename[FILENAME_MAX] = { 0 };
   44|  2.72k|    const u_char *pkt;
   45|  2.72k|    struct pcap_pkthdr *header;
   46|  2.72k|    struct pcap_stat stats;
   47|  2.72k|    int fd = -1, r;
   48|       |
   49|       |    //initialize output file
   50|  2.72k|    if (outfile == NULL) {
  ------------------
  |  Branch (50:9): [True: 1, False: 2.72k]
  ------------------
   51|      1|        outfile = fopen("/dev/null", "w");
   52|      1|        if (outfile == NULL) {
  ------------------
  |  Branch (52:13): [True: 0, False: 1]
  ------------------
   53|      0|            return 0;
   54|      0|        }
   55|      1|    }
   56|       |
   57|       |    //generate temporary file name
   58|  2.72k|    snprintf(filename, FILENAME_MAX, "/tmp/libpcap_fuzz_pcap.XXXXXX");
   59|  2.72k|    if ((fd = mkstemp(filename)) < 0) {
  ------------------
  |  Branch (59:9): [True: 0, False: 2.72k]
  ------------------
   60|      0|        return 0;
   61|      0|    }
   62|  2.72k|    close(fd);
   63|       |
   64|       |    //rewrite buffer to a file as libpcap does not have buffer inputs
   65|  2.72k|    if (bufferToFile(filename, Data, Size) < 0) {
  ------------------
  |  Branch (65:9): [True: 0, False: 2.72k]
  ------------------
   66|      0|        unlink(filename);
   67|      0|        return 0;
   68|      0|    }
   69|       |
   70|       |    //initialize structure
   71|  2.72k|    pkts = pcap_open_offline(filename, errbuf);
   72|  2.72k|    if (pkts == NULL) {
  ------------------
  |  Branch (72:9): [True: 826, False: 1.89k]
  ------------------
   73|    826|        fprintf(outfile, "Couldn't open pcap file %s\n", errbuf);
   74|    826|        unlink(filename);
   75|    826|        return 0;
   76|    826|    }
   77|       |
   78|       |    //loop over packets
   79|  1.89k|    r = pcap_next_ex(pkts, &header, &pkt);
   80|  51.0k|    while (r > 0) {
  ------------------
  |  Branch (80:12): [True: 49.1k, False: 1.89k]
  ------------------
   81|       |        //TODO pcap_offline_filter
   82|  49.1k|        fprintf(outfile, "packet length=%d/%d\n",header->caplen, header->len);
   83|  49.1k|        r = pcap_next_ex(pkts, &header, &pkt);
   84|  49.1k|    }
   85|  1.89k|    if (pcap_stats(pkts, &stats) == 0) {
  ------------------
  |  Branch (85:9): [True: 0, False: 1.89k]
  ------------------
   86|      0|        fprintf(outfile, "number of packets=%d\n", stats.ps_recv);
   87|      0|    }
   88|       |    //close structure
   89|  1.89k|    pcap_close(pkts);
   90|       |
   91|  1.89k|    unlink(filename);
   92|  1.89k|    return 0;
   93|  2.72k|}
fuzz_pcap.c:bufferToFile:
   12|  2.72k|static int bufferToFile(const char * name, const uint8_t *Data, size_t Size) {
   13|  2.72k|    FILE * fd;
   14|  2.72k|    if (remove(name) != 0) {
  ------------------
  |  Branch (14:9): [True: 0, False: 2.72k]
  ------------------
   15|      0|        if (errno != ENOENT) {
  ------------------
  |  Branch (15:13): [True: 0, False: 0]
  ------------------
   16|      0|            printf("failed remove, errno=%d\n", errno);
   17|      0|            return -1;
   18|      0|        }
   19|      0|    }
   20|  2.72k|    fd = fopen(name, "wb");
   21|  2.72k|    if (fd == NULL) {
  ------------------
  |  Branch (21:9): [True: 0, False: 2.72k]
  ------------------
   22|      0|        printf("failed open, errno=%d\n", errno);
   23|      0|        return -2;
   24|      0|    }
   25|  2.72k|    if (fwrite (Data, 1, Size, fd) != Size) {
  ------------------
  |  Branch (25:9): [True: 0, False: 2.72k]
  ------------------
   26|      0|        fclose(fd);
   27|      0|        return -3;
   28|      0|    }
   29|  2.72k|    fclose(fd);
   30|  2.72k|    return 0;
   31|  2.72k|}

